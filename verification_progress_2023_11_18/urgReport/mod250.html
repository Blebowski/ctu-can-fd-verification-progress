<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: CTU_CAN_FD_TB.FEATURE_TEST_AGENT_PKG</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-west">
<div name='tag_CTU_CAN_FD_TB.FEATURE_TEST_AGENT_PKG'>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_CTU_CAN_FD_TB.FEATURE_TEST_AGENT_PKG')">CTU_CAN_FD_TB.FEATURE_TEST_AGENT_PKG</a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s8 cl rt"> 87.96</td>
<td class="s8 cl rt"><a href="mod250.html#Line" > 87.96</a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/home/oille/Downloads/ctucanfd_ip_core/test/main_tb/agents/feature_test_agent/feature_test_agent_pkg.vhd')">/home/oille/Downloads/ctucanfd_ip_core/test/main_tb/agents/feature_test_agent/feature_test_agent_pkg.vhd</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr></table></div>
</div>
<br clear=all>
</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_CTU_CAN_FD_TB.FEATURE_TEST_AGENT_PKG'>
<a name="Line"></a>
Line Coverage for Module : <a href="mod250.html" >CTU_CAN_FD_TB.FEATURE_TEST_AGENT_PKG</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s8"><td class="lf">TOTAL</td><td></td><td>1063</td><td>935</td><td>87.96</td></tr>
<tr class="s10"><td class="lf">VHDL_FUNCTION</td><td>1920</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">VHDL_PROCEDURE</td><td>1929</td><td>19</td><td>17</td><td>89.47</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>1958</td><td>18</td><td>17</td><td>94.44</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>1985</td><td>18</td><td>17</td><td>94.44</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>2012</td><td>18</td><td>0</td><td>0.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2041</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2062</td><td>9</td><td>9</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2090</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2102</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2114</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">VHDL_PROCEDURE</td><td>2127</td><td>7</td><td>6</td><td>85.71</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2146</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2159</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">VHDL_PROCEDURE</td><td>2177</td><td>6</td><td>5</td><td>83.33</td></tr>
<tr class="s7"><td class="lf">VHDL_PROCEDURE</td><td>2194</td><td>5</td><td>4</td><td>80.00</td></tr>
<tr class="s7"><td class="lf">VHDL_PROCEDURE</td><td>2214</td><td>5</td><td>4</td><td>80.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2246</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2261</td><td>8</td><td>8</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">VHDL_PROCEDURE</td><td>2285</td><td>5</td><td>4</td><td>80.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2308</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2325</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2339</td><td>12</td><td>12</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>2375</td><td>12</td><td>0</td><td>0.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2406</td><td>12</td><td>12</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2428</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2453</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2475</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>2493</td><td>15</td><td>14</td><td>93.33</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>2539</td><td>21</td><td>20</td><td>95.24</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>2591</td><td>13</td><td>12</td><td>92.31</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2624</td><td>32</td><td>32</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>2704</td><td>20</td><td>20</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>2756</td><td>4</td><td>0</td><td>0.00</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>2775</td><td>30</td><td>28</td><td>93.33</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>2865</td><td>39</td><td>38</td><td>97.44</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>2950</td><td>19</td><td>18</td><td>94.74</td></tr>
<tr class="s6"><td class="lf">VHDL_PROCEDURE</td><td>2993</td><td>8</td><td>5</td><td>62.50</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>3042</td><td>41</td><td>37</td><td>90.24</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3125</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3139</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3159</td><td>10</td><td>10</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>3189</td><td>9</td><td>0</td><td>0.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3226</td><td>10</td><td>10</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3251</td><td>8</td><td>8</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>3272</td><td>15</td><td>0</td><td>0.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3320</td><td>9</td><td>9</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">VHDL_PROCEDURE</td><td>3349</td><td>11</td><td>9</td><td>81.82</td></tr>
<tr class="s8"><td class="lf">VHDL_PROCEDURE</td><td>3382</td><td>14</td><td>12</td><td>85.71</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3413</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3430</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3448</td><td>17</td><td>17</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3491</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>3512</td><td>6</td><td>0</td><td>0.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3530</td><td>44</td><td>44</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>3629</td><td>55</td><td>50</td><td>90.91</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3738</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3754</td><td>22</td><td>22</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>3807</td><td>36</td><td>36</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>3881</td><td>6</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>3903</td><td>5</td><td>0</td><td>0.00</td></tr>
<tr class="s10"><td class="lf">VHDL_FUNCTION</td><td>3920</td><td>26</td><td>26</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_FUNCTION</td><td>3979</td><td>26</td><td>26</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4041</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4053</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4065</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4078</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4094</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4107</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4124</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4143</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4162</td><td>8</td><td>8</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4183</td><td>8</td><td>8</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4215</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_FUNCTION</td><td>4231</td><td>10</td><td>10</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_FUNCTION</td><td>4258</td><td>9</td><td>9</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4282</td><td>11</td><td>11</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4312</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">VHDL_FUNCTION</td><td>4335</td><td>1</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">VHDL_FUNCTION</td><td>4347</td><td>3</td><td>0</td><td>0.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4362</td><td>19</td><td>19</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>4407</td><td>11</td><td>10</td><td>90.91</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4438</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4455</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4470</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>4488</td><td>11</td><td>10</td><td>90.91</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4518</td><td>16</td><td>16</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4558</td><td>8</td><td>8</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4580</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>4606</td><td>16</td><td>15</td><td>93.75</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>4649</td><td>24</td><td>22</td><td>91.67</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4690</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4702</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">VHDL_PROCEDURE</td><td>4717</td><td>4</td><td>3</td><td>75.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>4734</td><td>8</td><td>8</td><td>100.00</td></tr>
<tr class="s6"><td class="lf">VHDL_PROCEDURE</td><td>4754</td><td>28</td><td>18</td><td>64.29</td></tr>
<tr class="s7"><td class="lf">VHDL_PROCEDURE</td><td>4818</td><td>4</td><td>3</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
1919                        begin
1920       1/1                  return std_logic_vector(unsigned(operator1) + unsigned(operator2));
1921                        end function;
1922                    
1923                    
1924                    	procedure decode_length(
1925                    		constant length			: in	natural;
1926                    		variable dlc			: out	std_logic_vector(3 downto 0)
1927                    	) is
1928                    	begin
1929       1/1          		case length is
1930       1/1                  when 0 =&gt; dlc := &quot;0000&quot;;
1931       1/1                  when 1 =&gt; dlc := &quot;0001&quot;;
1932       1/1                  when 2 =&gt; dlc := &quot;0010&quot;;
1933       1/1                  when 3 =&gt; dlc := &quot;0011&quot;;
1934       1/1                  when 4 =&gt; dlc := &quot;0100&quot;;
1935       1/1                  when 5 =&gt; dlc := &quot;0101&quot;;
1936       1/1                  when 6 =&gt; dlc := &quot;0110&quot;;
1937       1/1                  when 7 =&gt; dlc := &quot;0111&quot;;
1938       1/1                  when 8 =&gt; dlc := &quot;1000&quot;;
1939       1/1                  when 12 =&gt; dlc := &quot;1001&quot;;
1940       1/1                  when 16 =&gt; dlc := &quot;1010&quot;;
1941       1/1                  when 20 =&gt; dlc := &quot;1011&quot;;
1942       1/1                  when 24 =&gt; dlc := &quot;1100&quot;;
1943       1/1                  when 32 =&gt; dlc := &quot;1101&quot;;
1944       1/1                  when 48 =&gt; dlc := &quot;1110&quot;;
1945       1/1                  when 64 =&gt; dlc := &quot;1111&quot;;
1946                            when others =&gt;
1947       <font color = "red">0/1     ==>  			error_m(&quot;Invalid data length&quot;);</font>
1948       <font color = "red">0/1     ==>  			dlc := &quot;0000&quot;;</font>
1949                            end case;
1950                    	end procedure;
1951                    
1952                    
1953                        procedure decode_dlc(
1954                            constant dlc            : in    std_logic_vector(3 downto 0);
1955                            variable length         : out   natural
1956                        )is
1957                        begin
1958       1/1                  case dlc is
1959       1/1                  when &quot;0000&quot; =&gt; length := 0;
1960       1/1                  when &quot;0001&quot; =&gt; length := 1;
1961       1/1                  when &quot;0010&quot; =&gt; length := 2;
1962       1/1                  when &quot;0011&quot; =&gt; length := 3;
1963       1/1                  when &quot;0100&quot; =&gt; length := 4;
1964       1/1                  when &quot;0101&quot; =&gt; length := 5;
1965       1/1                  when &quot;0110&quot; =&gt; length := 6;
1966       1/1                  when &quot;0111&quot; =&gt; length := 7;
1967       1/1                  when &quot;1000&quot; =&gt; length := 8;
1968       1/1                  when &quot;1001&quot; =&gt; length := 12;
1969       1/1                  when &quot;1010&quot; =&gt; length := 16;
1970       1/1                  when &quot;1011&quot; =&gt; length := 20;
1971       1/1                  when &quot;1100&quot; =&gt; length := 24;
1972       1/1                  when &quot;1101&quot; =&gt; length := 32;
1973       1/1                  when &quot;1110&quot; =&gt; length := 48;
1974       1/1                  when &quot;1111&quot; =&gt; length := 64;
1975       <font color = "red">0/1     ==>          when others =&gt; length := 0;</font>
1976                            end case;
1977                        end procedure;
1978                    
1979                    
1980                        procedure decode_dlc_rx_buff(
1981                            constant dlc            : in    std_logic_vector(3 downto 0);
1982                            variable rwcnt          : out   natural
1983                        )is
1984                        begin
1985       1/1                  case dlc is
1986       1/1                  when &quot;0000&quot; =&gt; rwcnt := 3;
1987       1/1                  when &quot;0001&quot; =&gt; rwcnt := 4;
1988       1/1                  when &quot;0010&quot; =&gt; rwcnt := 4;
1989       1/1                  when &quot;0011&quot; =&gt; rwcnt := 4;
1990       1/1                  when &quot;0100&quot; =&gt; rwcnt := 4;
1991       1/1                  when &quot;0101&quot; =&gt; rwcnt := 5;
1992       1/1                  when &quot;0110&quot; =&gt; rwcnt := 5;
1993       1/1                  when &quot;0111&quot; =&gt; rwcnt := 5;
1994       1/1                  when &quot;1000&quot; =&gt; rwcnt := 5;
1995       1/1                  when &quot;1001&quot; =&gt; rwcnt := 6;
1996       1/1                  when &quot;1010&quot; =&gt; rwcnt := 7;
1997       1/1                  when &quot;1011&quot; =&gt; rwcnt := 8;
1998       1/1                  when &quot;1100&quot; =&gt; rwcnt := 9;
1999       1/1                  when &quot;1101&quot; =&gt; rwcnt := 11;
2000       1/1                  when &quot;1110&quot; =&gt; rwcnt := 15;
2001       1/1                  when &quot;1111&quot; =&gt; rwcnt := 19;
2002       <font color = "red">0/1     ==>          when others =&gt; rwcnt := 0;</font>
2003                            end case;
2004                        end procedure;
2005                    
2006                    
2007                        procedure decode_dlc_buff(
2008                            constant dlc            : in    std_logic_vector(3 downto 0);
2009                            variable buff_space     : out   natural
2010                        )is
2011                        begin
2012       <font color = "red">0/1     ==>          case dlc is</font>
2013       <font color = "red">0/1     ==>          when &quot;0000&quot; =&gt; buff_space := 0 + 4; --Zero bits</font>
2014       <font color = "red">0/1     ==>          when &quot;0001&quot; =&gt; buff_space := 1 + 4; --1 byte</font>
2015       <font color = "red">0/1     ==>          when &quot;0010&quot; =&gt; buff_space := 1 + 4; --2 bytes</font>
2016       <font color = "red">0/1     ==>          when &quot;0011&quot; =&gt; buff_space := 1 + 4; --3 bytes</font>
2017       <font color = "red">0/1     ==>          when &quot;0100&quot; =&gt; buff_space := 1 + 4; --4 bytes</font>
2018       <font color = "red">0/1     ==>          when &quot;0101&quot; =&gt; buff_space := 2 + 4; --5 bytes</font>
2019       <font color = "red">0/1     ==>          when &quot;0110&quot; =&gt; buff_space := 2 + 4; --6 bytes</font>
2020       <font color = "red">0/1     ==>          when &quot;0111&quot; =&gt; buff_space := 2 + 4; --7 bytes</font>
2021       <font color = "red">0/1     ==>          when &quot;1000&quot; =&gt; buff_space := 2 + 4; --8 bytes</font>
2022       <font color = "red">0/1     ==>          when &quot;1001&quot; =&gt; buff_space := 3 + 4; --12 bytes</font>
2023       <font color = "red">0/1     ==>          when &quot;1010&quot; =&gt; buff_space := 4 + 4; --16 bytes</font>
2024       <font color = "red">0/1     ==>          when &quot;1011&quot; =&gt; buff_space := 5 + 4; --20 bytes</font>
2025       <font color = "red">0/1     ==>          when &quot;1100&quot; =&gt; buff_space := 6 + 4; --24 bytes</font>
2026       <font color = "red">0/1     ==>          when &quot;1101&quot; =&gt; buff_space := 8 + 4; --32 bytes</font>
2027       <font color = "red">0/1     ==>          when &quot;1110&quot; =&gt; buff_space := 12 + 4; --48 bytes</font>
2028       <font color = "red">0/1     ==>          when &quot;1111&quot; =&gt; buff_space := 16 + 4; --64 bytes</font>
2029       <font color = "red">0/1     ==>          when others =&gt; buff_space := 0;</font>
2030                            end case;
2031                        end procedure;
2032                    
2033                    
2034                        procedure id_hw_to_sw(
2035                            constant id_in          : in    std_logic_vector(28 downto 0);
2036                            constant id_type        : in    std_logic;
2037                            variable id_out         : out   natural
2038                        )is
2039                            variable tmp_vect       :       std_logic_vector(28 downto 0);
2040                        begin
2041       1/1                  if (id_type = EXTENDED) then
2042       1/1                      tmp_vect := id_in(IDENTIFIER_BASE_H downto
2043                                                  IDENTIFIER_BASE_L) &amp;
2044                                            id_in(IDENTIFIER_EXT_H downto
2045                                                  IDENTIFIER_EXT_L);
2046       1/1                      id_out   := to_integer(unsigned(tmp_vect));
2047                            else
2048       1/1                      tmp_vect   := &quot;000000000000000000&quot; &amp;
2049                                               id_in(IDENTIFIER_BASE_H downto IDENTIFIER_BASE_L);
2050       1/1                      id_out     := to_integer(unsigned(tmp_vect));
2051                            end if;
2052                        end procedure;
2053                    
2054                    
2055                        procedure id_sw_to_hw(
2056                            constant id_in          : in    natural;
2057                            constant id_type        : in    std_logic;
2058                            variable id_out         : out   std_logic_vector(28 downto 0)
2059                        )is
2060                            variable id_vect        :       std_logic_vector(28 downto 0);
2061                        begin
2062       1/1                  if (id_type = EXTENDED) then
2063       1/1                      check_m(id_in &lt; 536870912,
2064                                      &quot;Extended Identifier: &quot; &amp; integer'image(id_in) &amp;
2065                                      &quot; In range for Extended Identifier&quot;);
2066       1/1                      id_vect := std_logic_vector(to_unsigned(id_in, 29));
2067                    
2068       1/1                      id_out(IDENTIFIER_BASE_H downto IDENTIFIER_BASE_L) :=
2069                                    id_vect(28 downto 18);
2070       1/1                      id_out(IDENTIFIER_EXT_H downto IDENTIFIER_EXT_L) :=
2071                                    id_vect(17 downto 0);
2072                            else
2073       1/1                      check_m(id_in &lt; 2048,
2074                                      &quot;Base Identifier: &quot; &amp; integer'image(id_in) &amp;
2075                                      &quot; In range for Base Identifier&quot;);
2076       1/1                      id_vect := &quot;000000000000000000&quot; &amp;
2077                                               std_logic_vector(to_unsigned(id_in, 11));
2078       1/1                      id_out(IDENTIFIER_BASE_H downto IDENTIFIER_BASE_L) :=
2079                                    id_vect(10 downto 0);
2080       1/1                      id_out(IDENTIFIER_EXT_H downto IDENTIFIER_EXT_L) := (OTHERS =&gt; '0');
2081                            end if;
2082                        end procedure;
2083                    
2084                    
2085                        procedure force_bus_level(
2086                            constant value                  : in    std_logic;
2087                            signal   channel                : inout t_com_channel
2088                        ) is
2089                        begin
2090       1/1                  info_m(FEATURE_TEST_AGENT_TAG &amp;
2091                                 &quot;Forcing bus level to: &quot; &amp; std_logic'image(value));
2092       1/1                  com_channel_data.set_param(value);
2093       1/1                  send(channel, C_FEATURE_TEST_AGENT_ID, FEATURE_TEST_AGNT_FORCE_BUS);
2094       1/1                  debug_m(&quot;Bus level forced&quot;);
2095                        end procedure;
2096                    
2097                    
2098                        procedure release_bus_level(
2099                            signal channel                  : inout t_com_channel
2100                        ) is
2101                        begin
2102       1/1                  info_m(FEATURE_TEST_AGENT_TAG &amp; &quot;Releasing bus level&quot;);
2103       1/1                  send(channel, C_FEATURE_TEST_AGENT_ID, FEATURE_TEST_AGNT_RELEASE_BUS);
2104       1/1                  debug_m(&quot;Bus level released&quot;);
2105                        end procedure;
2106                    
2107                    
2108                        procedure check_bus_level(
2109                            constant value                    : in    std_logic;
2110                            constant msg                      : in    string;
2111                            signal   channel                  : inout t_com_channel
2112                        ) is
2113                        begin
2114       1/1                  info_m(FEATURE_TEST_AGENT_TAG &amp; msg);
2115       1/1                  com_channel_data.set_param(value);
2116       1/1                  send(channel, C_FEATURE_TEST_AGENT_ID, FEATURE_TEST_AGNT_CHECK_BUS_LEVEL);
2117       1/1                  debug_m(&quot;Bus level checked&quot;);
2118                        end procedure;
2119                    
2120                    
2121                        procedure force_can_rx(
2122                            constant value           : in    std_logic;
2123                            constant node            : in    t_feature_node;
2124                            signal   channel         : inout t_com_channel
2125                        ) is
2126                        begin
2127       1/1                  info_m(FEATURE_TEST_AGENT_TAG &amp;
2128                                 &quot;Forcing CAN RX of: &quot; &amp; t_feature_node'image(node) &amp;
2129                                 &quot; to: &quot; &amp; std_logic'image(value));
2130                    
2131       1/1                  com_channel_data.set_param(value);
2132       1/1                  if (node = DUT_NODE) then
2133       1/1                      com_channel_data.set_param(0);
2134                            else
2135       <font color = "red">0/1     ==>              com_channel_data.set_param(1);</font>
2136                            end if;
2137       1/1                  send(channel, C_FEATURE_TEST_AGENT_ID, FEATURE_TEST_AGNT_FORCE_CAN_RX);
2138       1/1                  debug_m(&quot;CAN RX forced&quot;);
2139                        end procedure;
2140                    
2141                    
2142                        procedure release_can_rx(
2143                            signal   channel         : inout t_com_channel
2144                        ) is
2145                        begin
2146       1/1                  info_m(FEATURE_TEST_AGENT_TAG &amp; &quot;Releasing CAN RX&quot;);
2147       1/1                  send(channel, C_FEATURE_TEST_AGENT_ID, FEATURE_TEST_AGNT_RELEASE_CAN_RX);
2148       1/1                  debug_m(&quot;CAN RX released&quot;);
2149                        end procedure;
2150                    
2151                    
2152                        procedure check_can_tx(
2153                            constant value              : in    std_logic;
2154                            constant node               : in    t_feature_node;
2155                            constant msg                : in    string;
2156                            signal   channel            : inout t_com_channel
2157                        ) is
2158                        begin
2159       1/1                  info_m(FEATURE_TEST_AGENT_TAG &amp; msg);
2160       1/1                  if (node = DUT_NODE) then
2161       1/1                      com_channel_data.set_param(0);
2162                            else
2163       1/1                      com_channel_data.set_param(1);
2164                            end if;
2165       1/1                  com_channel_data.set_param(value);
2166       1/1                  send(channel, C_FEATURE_TEST_AGENT_ID, FEATURE_TEST_AGNT_CHECK_CAN_TX);
2167       1/1                  debug_m(&quot;CAN TX Checked&quot;);
2168                        end procedure;
2169                    
2170                    
2171                        procedure get_can_tx(
2172                            constant node               : in    t_feature_node;
2173                            variable value              : out   std_logic;
2174                            signal   channel            : inout t_com_channel
2175                        ) is
2176                        begin
2177       1/1                  if (node = DUT_NODE) then
2178       1/1                      com_channel_data.set_param(0);
2179                            else
2180       <font color = "red">0/1     ==>              com_channel_data.set_param(1);</font>
2181                            end if;
2182       1/1                  com_channel_data.set_param(value);
2183       1/1                  send(channel, C_FEATURE_TEST_AGENT_ID, FEATURE_TEST_AGNT_GET_CAN_TX);
2184       1/1                  value := com_channel_data.get_param;
2185                        end procedure;
2186                    
2187                    
2188                        procedure get_can_rx(
2189                            constant node               : in    t_feature_node;
2190                            variable value              : out   std_logic;
2191                            signal   channel            : inout t_com_channel
2192                        ) is
2193                        begin
2194       1/1                  if (node = DUT_NODE) then
2195       1/1                      com_channel_data.set_param(0);
2196                            else
2197       <font color = "red">0/1     ==>              com_channel_data.set_param(1);</font>
2198                            end if;
2199       1/1                  send(channel, C_FEATURE_TEST_AGENT_ID, FEATURE_TEST_AGNT_GET_CAN_RX);
2200       1/1                  value := com_channel_data.get_param;
2201                        end procedure;
2202                    
2203                    
2204                        procedure CAN_write(
2205                            constant  w_data        : in    std_logic_vector;
2206                            constant  w_offset      : in    std_logic_vector(11 downto 0);
2207                            constant  node          : in    t_feature_node;
2208                            signal    channel       : inout t_com_channel;
2209                            constant  stat_burst    : in    boolean := false
2210                        )is
2211                        begin
2212                    
2213                            -- Set chip select
2214       1/1                  if (node = DUT_NODE) then
2215       1/1                      mem_bus_agent_set_slave_index(channel, 0);
2216                            elsif (node = TEST_NODE) then
2217       1/1                      mem_bus_agent_set_slave_index(channel, 1);
2218                            else
2219       <font color = "red">0/1     ==>              error_m(&quot;Invalid slave node&quot;);</font>
2220                            end if;
2221                    
2222                            -- Memory bus agent should handle also bursts
2223       1/1                  mem_bus_agent_write(
2224                                channel =&gt; channel,
2225                                address =&gt; to_integer(unsigned(w_offset)),
2226                                write_data =&gt; w_data,
2227                                blocking =&gt; true
2228                            );
2229                        end procedure;
2230                    
2231                    
2232                        procedure CAN_write_by_byte(
2233                            constant  w_data        : in    std_logic_vector(31 downto 0);
2234                            constant  w_offset      : in    std_logic_vector(11 downto 0);
2235                            constant  node          : in    t_feature_node;
2236                            signal    channel       : inout t_com_channel
2237                        )is
2238                            variable word_addr : natural := to_integer(unsigned(w_offset));
2239                            variable byte_1_addr : std_logic_vector(11 downto 0) :=
2240                                std_logic_vector(to_unsigned(word_addr + 1, 12));
2241                            variable byte_2_addr : std_logic_vector(11 downto 0) :=
2242                                std_logic_vector(to_unsigned(word_addr + 2, 12));
2243                            variable byte_3_addr : std_logic_vector(11 downto 0) :=
2244                                std_logic_vector(to_unsigned(word_addr + 3, 12));
2245                        begin
2246       1/1                  CAN_write(w_data(7 downto 0), w_offset, node, channel);
2247       1/1                  CAN_write(w_data(15 downto 8), byte_1_addr, node, channel);
2248       1/1                  CAN_write(w_data(23 downto 16), byte_2_addr, node, channel);
2249       1/1                  CAN_write(w_data(31 downto 24), byte_3_addr, node, channel);
2250                        end procedure;
2251                    
2252                    
2253                        procedure CAN_read_by_byte(
2254                            variable  r_data        : out   std_logic_vector(31 downto 0);
2255                            constant  r_offset      : in    std_logic_vector(11 downto 0);
2256                            constant  node          : in    t_feature_node;
2257                            signal    channel       : inout t_com_channel
2258                        )is
2259                            variable data : std_logic_vector(7 downto 0);
2260                        begin
2261       1/1                  CAN_read(data, r_offset, node, channel);
2262       1/1                  r_data(7 downto 0) := data;
2263                    
2264       1/1                  CAN_read(data, CAN_add_unsigned(r_offset, x&quot;001&quot;), node, channel);
2265       1/1                  r_data(15 downto 8) := data;
2266                    
2267       1/1                  CAN_read(data, CAN_add_unsigned(r_offset, x&quot;002&quot;), node, channel);
2268       1/1                  r_data(23 downto 16) := data;
2269                    
2270       1/1                  CAN_read(data, CAN_add_unsigned(r_offset, x&quot;003&quot;), node, channel);
2271       1/1                  r_data(31 downto 24) := data;
2272                        end procedure;
2273                    
2274                    
2275                        procedure CAN_read(
2276                            variable  r_data        : out   std_logic_vector;
2277                            constant  r_offset      : in    std_logic_vector(11 downto 0);
2278                            constant  node          : in    t_feature_node;
2279                            signal    channel       : inout t_com_channel;
2280                            constant  stat_burst    : in    boolean := false
2281                        )is
2282                        begin
2283                    
2284                            -- Set chip select
2285       1/1                  if (node = DUT_NODE) then
2286       1/1                      mem_bus_agent_set_slave_index(channel, 0);
2287                            elsif (node = TEST_NODE) then
2288       1/1                      mem_bus_agent_set_slave_index(channel, 1);
2289                            else
2290       <font color = "red">0/1     ==>              error_m(&quot;Invalid slave node&quot;);</font>
2291                            end if;
2292                    
2293       1/1                  mem_bus_agent_read(
2294                                channel  =&gt; channel,
2295                                address  =&gt; to_integer(unsigned(r_offset)),
2296                                read_data =&gt; r_data,
2297                                stat_burst =&gt; stat_burst
2298                            );
2299                        end procedure;
2300                    
2301                    
2302                        procedure ftr_tb_set_tran_delay(
2303                            constant tx_del         : in    time;
2304                            constant node           : in    t_feature_node;
2305                            signal   channel        : inout t_com_channel
2306                        )is
2307                        begin
2308       1/1                  info_m(FEATURE_TEST_AGENT_TAG &amp; &quot; Setting transceiver delay&quot;);
2309       1/1                  com_channel_data.set_param(tx_del);
2310       1/1                  if (node = DUT_NODE) then
2311       1/1                      com_channel_data.set_param(0);
2312                            else
2313       1/1                      com_channel_data.set_param(1);
2314                            end if;
2315       1/1                  send(channel, C_FEATURE_TEST_AGENT_ID, FEATURE_TEST_AGNT_SET_TRV_DELAY);
2316       1/1                  debug_m(FEATURE_TEST_AGENT_TAG &amp; &quot; Transceiver delay set&quot;);
2317                        end procedure;
2318                    
2319                    
2320                        procedure ftr_tb_set_timestamp(
2321                            constant ts_value       : in    std_logic_vector(63 downto 0);
2322                            signal   channel        : inout t_com_channel
2323                        )is
2324                        begin
2325       1/1                  timestamp_agent_timestamp_preset(channel, ts_value);
2326                        end procedure;
2327                    
2328                    
2329                        procedure CAN_configure_timing(
2330                            constant bus_timing     : in    bit_time_config_type;
2331                            constant node           : in    t_feature_node;
2332                            signal   channel        : inout t_com_channel
2333                        )is
2334                            variable data           :       std_logic_vector(31 downto 0) :=
2335                                                            (OTHERS =&gt; '0');
2336                        begin
2337                    
2338                            -- Bit timing register - Nominal
2339       1/1                  data(BRP_H downto BRP_L) := std_logic_vector(to_unsigned(
2340                                    bus_timing.tq_nbt, BRP_H - BRP_L + 1));
2341       1/1                  data(PROP_H downto PROP_L) := std_logic_vector(to_unsigned(
2342                                    bus_timing.prop_nbt, PROP_H - PROP_L + 1));
2343       1/1                  data(PH1_H downto PH1_L) := std_logic_vector(to_unsigned(
2344                                    bus_timing.ph1_nbt, PH1_H - PH1_L + 1));
2345       1/1                  data(PH2_H downto PH2_L) := std_logic_vector(to_unsigned(
2346                                    bus_timing.ph2_nbt, PH2_H - PH2_L + 1));
2347       1/1                  data(SJW_H downto SJW_L) := std_logic_vector(to_unsigned(
2348                                    bus_timing.sjw_nbt, SJW_H - SJW_L + 1));
2349       1/1                  CAN_write(data, BTR_ADR, node, channel);
2350                    
2351                            -- Bit timing register - Data
2352       1/1                  data(BRP_FD_H downto BRP_FD_L) := std_logic_vector(to_unsigned(
2353                                    bus_timing.tq_dbt, BRP_FD_H - BRP_FD_L + 1));
2354       1/1                  data(PROP_FD_H downto PROP_FD_L) := std_logic_vector(to_unsigned(
2355                                    bus_timing.prop_dbt, PROP_FD_H - PROP_FD_L + 1));
2356       1/1                  data(PH1_FD_H downto PH1_FD_L) := std_logic_vector(to_unsigned(
2357                                    bus_timing.ph1_dbt, PH1_FD_H - PH1_FD_L + 1));
2358       1/1                  data(PH2_FD_H downto PH2_FD_L) := std_logic_vector(to_unsigned(
2359                                    bus_timing.ph2_dbt, PH2_FD_H - PH2_FD_L + 1));
2360       1/1                  data(SJW_FD_H downto SJW_FD_L) := std_logic_vector(to_unsigned(
2361                                    bus_timing.sjw_dbt, SJW_FD_H - SJW_FD_L + 1));
2362       1/1                  CAN_write(data, BTR_FD_ADR, node, channel);
2363                        end procedure;
2364                    
2365                    
2366                        procedure CAN_read_timing(
2367                            signal   bus_timing     : out   bit_time_config_type;
2368                            constant node           : in    t_feature_node;
2369                            signal   channel        : inout t_com_channel
2370                        )is
2371                            variable data           :       std_logic_vector(31 downto 0);
2372                        begin
2373                    
2374                            -- Bit timing register - Nominal
2375       <font color = "red">0/1     ==>          CAN_read(data, BTR_ADR, node, channel);</font>
2376       <font color = "red">0/1     ==>          bus_timing.tq_nbt    &lt;= to_integer(unsigned(data(BRP_H downto BRP_L)));</font>
2377       <font color = "red">0/1     ==>          bus_timing.prop_nbt  &lt;= to_integer(unsigned(data(PROP_H downto PROP_L)));</font>
2378       <font color = "red">0/1     ==>          bus_timing.ph1_nbt   &lt;= to_integer(unsigned(data(PH1_H downto PH1_L)));</font>
2379       <font color = "red">0/1     ==>          bus_timing.ph2_nbt   &lt;= to_integer(unsigned(data(PH2_H downto PH2_L)));</font>
2380       <font color = "red">0/1     ==>          bus_timing.sjw_nbt   &lt;= to_integer(unsigned(data(SJW_H downto SJW_L)));</font>
2381                    
2382                            -- Bit timing register - Data
2383       <font color = "red">0/1     ==>          CAN_read(data, BTR_FD_ADR, node, channel);</font>
2384       <font color = "red">0/1     ==>          bus_timing.tq_dbt    &lt;= to_integer(unsigned(data(BRP_FD_H downto</font>
2385                                                                             BRP_FD_L)));
2386       <font color = "red">0/1     ==>          bus_timing.prop_dbt  &lt;= to_integer(unsigned(data(PROP_FD_H downto</font>
2387                                                                             PROP_FD_L)));
2388       <font color = "red">0/1     ==>          bus_timing.ph1_dbt   &lt;= to_integer(unsigned(data(PH1_FD_H downto</font>
2389                                                                             PH1_FD_L)));
2390       <font color = "red">0/1     ==>          bus_timing.ph2_dbt   &lt;= to_integer(unsigned(data(PH2_FD_H downto</font>
2391                                                                             PH2_FD_L)));
2392       <font color = "red">0/1     ==>          bus_timing.sjw_dbt   &lt;= to_integer(unsigned(data(SJW_FD_H downto</font>
2393                                                                             SJW_FD_L)));
2394                        end procedure;
2395                    
2396                    
2397                        procedure CAN_read_timing_v(
2398                            variable bus_timing     : out   bit_time_config_type;
2399                            constant node           : in    t_feature_node;
2400                            signal   channel        : inout t_com_channel
2401                        )is
2402                            variable data           :       std_logic_vector(31 downto 0);
2403                        begin
2404                    
2405                            -- Bit timing register - Nominal
2406       1/1                  CAN_read(data, BTR_ADR, node, channel);
2407       1/1                  bus_timing.tq_nbt    := to_integer(unsigned(data(BRP_H downto BRP_L)));
2408       1/1                  bus_timing.prop_nbt  := to_integer(unsigned(data(PROP_H downto PROP_L)));
2409       1/1                  bus_timing.ph1_nbt   := to_integer(unsigned(data(PH1_H downto PH1_L)));
2410       1/1                  bus_timing.ph2_nbt   := to_integer(unsigned(data(PH2_H downto PH2_L)));
2411       1/1                  bus_timing.sjw_nbt   := to_integer(unsigned(data(SJW_H downto SJW_L)));
2412                    
2413                            -- Bit timing register - Data
2414       1/1                  CAN_read(data, BTR_FD_ADR, node, channel);
2415       1/1                  bus_timing.tq_dbt    := to_integer(unsigned(data(BRP_FD_H downto BRP_FD_L)));
2416       1/1                  bus_timing.prop_dbt  := to_integer(unsigned(data(PROP_FD_H downto PROP_FD_L)));
2417       1/1                  bus_timing.ph1_dbt   := to_integer(unsigned(data(PH1_FD_H downto PH1_FD_L)));
2418       1/1                  bus_timing.ph2_dbt   := to_integer(unsigned(data(PH2_FD_H downto PH2_FD_L)));
2419       1/1                  bus_timing.sjw_dbt   := to_integer(unsigned(data(SJW_FD_H downto SJW_FD_L)));
2420                        end procedure;
2421                    
2422                    
2423                        procedure CAN_print_timing(
2424                            constant   bus_timing       : in    bit_time_config_type
2425                        )is
2426                            variable msg                :       line;
2427                        begin
2428       1/1                  info_m(&quot;Nominal Bit timing: &quot; &amp;
2429                                 &quot;BRP:  &quot; &amp; integer'image(bus_timing.tq_nbt) &amp; &quot; &quot; &amp;
2430                                 &quot;PROP: &quot; &amp; integer'image(bus_timing.prop_nbt) &amp; &quot; &quot; &amp;
2431                                 &quot;PH1:  &quot; &amp; integer'image(bus_timing.ph1_nbt) &amp; &quot; &quot; &amp;
2432                                 &quot;PH2:  &quot; &amp; integer'image(bus_timing.ph2_nbt) &amp; &quot; &quot; &amp;
2433                                 &quot;SJW:  &quot; &amp; integer'image(bus_timing.sjw_nbt));
2434                    
2435       1/1                  info_m(&quot;Data Bit timing: &quot; &amp;
2436                                 &quot;BRP:  &quot; &amp; integer'image(bus_timing.tq_dbt) &amp;
2437                                 &quot;PROP: &quot; &amp; integer'image(bus_timing.prop_dbt) &amp;
2438                                 &quot;PH1:  &quot; &amp; integer'image(bus_timing.ph1_dbt) &amp;
2439                                 &quot;PH2:  &quot; &amp; integer'image(bus_timing.ph2_dbt) &amp;
2440                                 &quot;SJW:  &quot; &amp; integer'image(bus_timing.sjw_dbt));
2441                        end procedure;
2442                    
2443                    
2444                        procedure CAN_turn_controller(
2445                            constant turn_on        : in    boolean;
2446                            constant node           : in    t_feature_node;
2447                            signal   channel        : inout t_com_channel
2448                        )is
2449                            variable data           :       std_logic_vector(31 downto 0) :=
2450                                                            (OTHERS =&gt; '0');
2451                            variable readback       :       std_logic_vector(31 downto 0);
2452                        begin
2453       1/1                  CAN_read(data, MODE_ADR, node, channel);
2454       1/1                  if turn_on then
2455       1/1                      data(ENA_IND) := CTU_CAN_ENABLED;
2456                            else
2457       1/1                      data(ENA_IND) := CTU_CAN_DISABLED;
2458                            end if;
2459       1/1                  CAN_write(data, MODE_ADR, node, channel);
2460       1/1                  CAN_read(readback, MODE_ADR, node, channel);
2461       1/1                  assert readback = data;
2462                        end procedure;
2463                    
2464                    
2465                        procedure CAN_enable_retr_limit(
2466                            constant enable         : in    boolean;
2467                            constant limit          : in    natural range 0 to 15;
2468                            constant node           : in    t_feature_node;
2469                            signal   channel        : inout t_com_channel
2470                        )is
2471                            variable data : std_logic_vector(15 downto 0) := (OTHERS =&gt; '0');
2472                            variable low : natural := RTRTH_L mod 16;
2473                            variable high : natural := RTRTH_H mod 16;
2474                        begin
2475       1/1                  CAN_read(data, SETTINGS_ADR, node, channel);
2476       1/1                  if enable then
2477       1/1                      data(RTRLE_IND mod 16) := '1';
2478                            else
2479       1/1                      data(RTRLE_IND mod 16) := '0';
2480                            end if;
2481       1/1                  data(high downto low) := std_logic_vector(to_unsigned(limit, 4));
2482       1/1                  CAN_write(data, SETTINGS_ADR, node, channel);
2483                        end procedure;
2484                    
2485                    
2486                        procedure config_filter_frame_types(
2487                            constant ident_type     : in    std_logic;
2488                            constant acc_CAN_2_0    : in    boolean;
2489                            constant acc_CAN_FD     : in    boolean;
2490                            variable cfg            : inout std_logic_vector(3 downto 0)
2491                        ) is
2492                        begin
2493       1/1                  cfg := (OTHERS =&gt; '0');
2494       1/1                  if (ident_type = BASE) then
2495       1/1                      if (acc_CAN_2_0) then
2496       1/1                          cfg(0) := '1';
2497                                else
2498       1/1                          cfg(0) := '0';
2499                                end if;
2500       1/1                      if (acc_CAN_FD) then
2501       1/1                          cfg(2) := '1';
2502                                else
2503       1/1                          cfg(2) := '0';
2504                                end if;
2505                            elsif (ident_type = EXTENDED) then
2506       1/1                      if (acc_CAN_2_0) then
2507       1/1                          cfg(1) := '1';
2508                                else
2509       1/1                          cfg(1) := '0';
2510                                end if;
2511       1/1                      if (acc_CAN_FD) then
2512       1/1                          cfg(3) := '1';
2513                                else
2514       1/1                          cfg(3) := '0';
2515                                end if;
2516                            else
2517       <font color = "red">0/1     ==>              error_m(&quot;Unsupported CAN frame type&quot;);</font>
2518                            end if;
2519                        end procedure;
2520                    
2521                    
2522                        procedure CAN_set_mask_filter(
2523                            constant filter         : in    SW_CAN_mask_filter_type;
2524                            constant config         : in    SW_CAN_mask_filter_config;
2525                            constant node           : in    t_feature_node;
2526                            signal   channel        : inout t_com_channel
2527                        ) is
2528                            variable mask_offset    :       std_logic_vector(11 downto 0);
2529                            variable value_offset   :       std_logic_vector(11 downto 0);
2530                            variable data           :       std_logic_vector(31 downto 0) :=
2531                                                                (OTHERS =&gt; '0');
2532                            variable ident_vect     :       std_logic_vector(28 downto 0) :=
2533                                                                (OTHERS =&gt; '0');
2534                            variable ctrl_offset    :       natural range 0 to 11 := 0;
2535                            variable tmp            :       std_logic_vector(3 downto 0) :=
2536                                                                (OTHERS =&gt; '0');
2537                        begin
2538                    
2539       1/1                  if (filter = filter_A) then
2540       1/1                      mask_offset  := FILTER_A_MASK_ADR;
2541       1/1                      value_offset := FILTER_A_VAL_ADR;
2542       1/1                      ctrl_offset  := FANB_IND;
2543                            elsif (filter = filter_B) then
2544       1/1                      mask_offset := FILTER_B_MASK_ADR;
2545       1/1                      value_offset := FILTER_B_VAL_ADR;
2546       1/1                      ctrl_offset  := FBNB_IND;
2547                            elsif (filter = filter_C) then
2548       1/1                      mask_offset := FILTER_C_MASK_ADR;
2549       1/1                      value_offset := FILTER_C_VAL_ADR;
2550       1/1                      ctrl_offset  := FCNB_IND;
2551                            else
2552       <font color = "red">0/1     ==>              error_m(&quot;Unsupported mask filter!&quot;);</font>
2553                            end if;
2554                    
2555                            -- Configure filter mask
2556       1/1                  id_sw_to_hw(config.ID_mask, config.ident_type, ident_vect);
2557       1/1                  data := &quot;000&quot; &amp; ident_vect;
2558       1/1                  CAN_write(data, mask_offset, node, channel);
2559                    
2560                            -- Configure filter value
2561       1/1                  id_sw_to_hw(config.ID_value, config.ident_type, ident_vect);
2562       1/1                  data := &quot;000&quot; &amp; ident_vect;
2563       1/1                  CAN_write(data, value_offset, node, channel);
2564                    
2565                            -- Configure Accepted frame types
2566       1/1                  CAN_read(data, FILTER_CONTROL_ADR, node, channel);
2567       1/1                  config_filter_frame_types(config.ident_type, config.acc_CAN_2_0,
2568                                                      config.acc_CAN_FD, tmp);
2569       1/1                  data(ctrl_offset + 3 downto ctrl_offset) := tmp;
2570       1/1                  CAN_write(data, FILTER_CONTROL_ADR, node, channel);
2571                    
2572                        end procedure;
2573                    
2574                    
2575                        procedure CAN_set_range_filter(
2576                            constant config         : in    SW_CAN_range_filter_config;
2577                            constant node           : in    t_feature_node;
2578                            signal   channel        : inout t_com_channel
2579                        ) is
2580                            variable data           :       std_logic_vector(31 downto 0) :=
2581                                                                (OTHERS =&gt; '0');
2582                            variable ident_lth_vect :       std_logic_vector(28 downto 0) :=
2583                                                                (OTHERS =&gt; '0');
2584                            variable ident_hth_vect :       std_logic_vector(28 downto 0) :=
2585                                                                (OTHERS =&gt; '0');
2586                            variable tmp            :       std_logic_vector(3 downto 0) :=
2587                                                                (OTHERS =&gt; '0');
2588                        begin
2589                    
2590                            -- Check High threshold aint lower than Low threshold
2591       1/1                  if (config.ID_th_low &gt; config.ID_th_high) then
2592       <font color = "red">0/1     ==>              warning_m(&quot;High threshold of Range filter Lower than Low threshold!&quot;);</font>
2593                            end if;
2594       1/1                  id_sw_to_hw(config.ID_th_high, config.ident_type, ident_hth_vect);
2595                    
2596                            -- Low threshold
2597       1/1                  id_sw_to_hw(config.ID_th_low, config.ident_type, ident_lth_vect);
2598       1/1                  data := &quot;000&quot; &amp; ident_lth_vect;
2599       1/1                  CAN_write(data, FILTER_RAN_LOW_ADR, node, channel);
2600                    
2601                            -- High threshold
2602       1/1                  id_sw_to_hw(config.ID_th_high, config.ident_type, ident_hth_vect);
2603       1/1                  data := &quot;000&quot; &amp; ident_hth_vect;
2604       1/1                  CAN_write(data, FILTER_RAN_HIGH_ADR, node, channel);
2605                    
2606                            -- Configure accepted Frame types
2607       1/1                  CAN_read(data, FILTER_CONTROL_ADR, node, channel);
2608       1/1                  config_filter_frame_types(config.ident_type, config.acc_CAN_2_0,
2609                                                      config.acc_CAN_FD, tmp);
2610       1/1                  data(FRFE_IND downto FRNB_IND) := tmp;
2611       1/1                  CAN_write(data, FILTER_CONTROL_ADR, node, channel);
2612                    
2613                        end procedure;
2614                    
2615                    
2616                        procedure CAN_generate_frame(
2617                            variable frame          : inout SW_CAN_frame_type
2618                        )is
2619                            variable rand_value     : real := 0.0;
2620                            variable aux            : std_logic_vector(28 downto 0);
2621                            variable data_byte      : std_logic_vector(7 downto 0);
2622                        begin
2623                    
2624       1/1                  rand_logic_v(frame.ident_type, 0.5);
2625       1/1                  rand_logic_v(frame.frame_format, 0.5);
2626       1/1                  rand_logic_v(frame.rtr, 0.5);
2627       1/1                  rand_logic_v(frame.brs, 0.5);
2628       1/1                  rand_logic_vect_v(frame.dlc, 0.3);
2629                    
2630       1/1                  rand_real_v(rand_value);
2631                    
2632                            ------------------------------------------------------------------------
2633                            -- We generate only valid frame combinations to avoid problems...
2634                            -- FD frames has no RTR frame, neither the RTR field!
2635                            ------------------------------------------------------------------------
2636       1/1                  if (frame.frame_format = FD_CAN) then
2637       1/1                      frame.rtr := NO_RTR_FRAME;
2638                            end if;
2639                    
2640                            ------------------------------------------------------------------------
2641                            -- CAN 2.0 Frame has no BRS bit. Furthermore maximal data length
2642                            -- of CAN 2.0 Frame is 8 bytes.
2643                            ------------------------------------------------------------------------
2644       1/1                  if (frame.frame_format = NORMAL_CAN) then
2645       1/1                      frame.brs := BR_NO_SHIFT;
2646                    
2647                                -- Limit DLCs higher than 8 to max. 8!
2648       1/1                      if (frame.dlc(3) = '1' and frame.dlc(2 downto 0) /= &quot;000&quot;) then
2649       1/1                          frame.dlc(3) := '0';
2650                                end if;
2651                            end if;
2652                    
2653                            -- If base identifier, the lowest bits of unsigned ID contain the
2654                            -- basic value!
2655       1/1                  aux := (OTHERS =&gt; '0');
2656       1/1                  if (frame.ident_type = BASE) then
2657       1/1                      rand_value          := rand_value * 2047.0;
2658       1/1                      aux(10 downto 0)    := std_logic_vector(
2659                                                       to_unsigned(integer(rand_value), 11));
2660                            else
2661       1/1                      rand_value          := rand_value * 536870911.0;
2662       1/1                      aux(28 downto 0)    := std_logic_vector(
2663                                                       to_unsigned(integer(rand_value), 29));
2664                            end if;
2665       1/1                  frame.identifier := to_integer(unsigned(aux));
2666                    
2667       1/1                  decode_dlc(frame.dlc, frame.data_length);
2668       1/1                  frame.timestamp := (OTHERS =&gt; '0');
2669                    
2670       1/1                  if (frame.rtr = RTR_FRAME) then
2671       1/1                      frame.data          := (OTHERS =&gt; (OTHERS =&gt; '0'));
2672       1/1                      frame.dlc           := (OTHERS =&gt; '0');
2673       1/1                      frame.data_length   := 0;
2674                            end if;
2675                    
2676                            -- RWCNT is filled to have all information in the frame
2677                            -- as is filled by the RX Buffer.
2678       1/1                  decode_dlc_rx_buff(frame.dlc, frame.rwcnt);
2679                    
2680                            -- ESI is read only, but is is better to have initialized value in it!
2681       1/1                  frame.esi := '0';
2682                    
2683                            -- Generate random data
2684                            -- Unused bytes of data can be set to 0
2685       1/1                  frame.data := (OTHERS =&gt; (OTHERS =&gt; '0'));
2686       1/1                  if (frame.data_length &gt; 0) then
2687       1/1                      for i in 0 to frame.data_length - 1 loop
2688       1/1                          rand_logic_vect_v(data_byte, 0.5);
2689       1/1                          frame.data(i) := data_byte;
2690                                end loop;
2691                            end if;
2692                    
2693                        end procedure;
2694                    
2695                    
2696                        procedure CAN_print_frame(
2697                            constant frame          : in    SW_CAN_frame_type
2698                        )is
2699                            variable data_byte      :       std_logic_vector(7 downto 0);
2700                            variable str_msg        :       string(1 to 400) := (OTHERS =&gt; ' ');
2701                            variable str_len        :       natural := 0;
2702                        begin
2703                    
2704       1/1                  info_m(&quot;*************************************************************&quot;);
2705                    
2706                            -- Identifier
2707       1/1                  info_m(&quot;ID : 0x&quot; &amp;
2708                                to_hstring(std_logic_vector(to_unsigned(frame.identifier, 32))));
2709                    
2710                            -- Metadata
2711       1/1                  info_m(&quot;DLC: &quot; &amp; to_hstring(frame.dlc) &amp; &quot;, Data length:&quot; &amp;
2712                                  to_string(frame.data_length));
2713                    
2714       1/1                  if (frame.rtr = RTR_FRAME) then
2715       1/1                      info_m(&quot;RTR Frame&quot;);
2716                            end if;
2717                    
2718       1/1                  if (frame.ident_type = BASE) then
2719       1/1                      info_m(&quot;BASE identifier&quot;);
2720                            else
2721       1/1                      info_m(&quot;EXTENDED identifier&quot;);
2722                            end if;
2723                    
2724       1/1                  if (frame.frame_format = NORMAL_CAN) then
2725       1/1                      info_m(&quot;CAN 2.0 frame&quot;);
2726                            else
2727       1/1                      info_m(&quot;CAN FD frame&quot;);
2728                            end if;
2729                    
2730       1/1                  info_m(&quot;RWCNT (read word count): &quot; &amp;
2731                                to_string(std_logic_vector(to_unsigned(frame.rwcnt, 10))));
2732                    
2733                            -- Data words
2734       1/1                  if (frame.rtr = NO_RTR_FRAME and frame.data_length &gt; 0) then
2735       1/1                      str_msg(1 to 6) := &quot;Data: &quot;;
2736       1/1                      str_len := 6 + 5 * frame.data_length;
2737       1/1                      for i in 0 to frame.data_length - 1 loop
2738       1/1                          data_byte := frame.data(i);
2739       1/1                          str_msg(7 + i * 5 to 11 + i * 5) :=
2740                                        &quot;0x&quot; &amp; to_hstring(frame.data(i)) &amp; &quot; &quot;;
2741                                end loop;
2742       1/1                      info_m(str_msg(1 to str_len));
2743                            end if;
2744                    
2745       1/1                  info_m(&quot;*************************************************************&quot;);
2746                        end procedure;
2747                    
2748                    
2749                        procedure CAN_print_frame_simple(
2750                            constant frame          : in    SW_CAN_frame_type
2751                        )is
2752                            variable data_byte      :       std_logic_vector(7 downto 0);
2753                            variable str_msg        :       string(1 to 512) := (OTHERS =&gt; ' ');
2754                        begin
2755                    
2756       <font color = "red">0/1     ==>          str_msg(1 to 10) := &quot;CAN Frame:&quot;;</font>
2757                    
2758                            -- Identifier
2759       <font color = "red">0/1     ==>          str_msg(11 to 18) := &quot; ID : 0x&quot;;</font>
2760       <font color = "red">0/1     ==>          str_msg(19 to 26) :=</font>
2761                                to_hstring(std_logic_vector(to_unsigned(frame.identifier, 32)));
2762                    
2763                    
2764       <font color = "red">0/1     ==>          info_m(str_msg);</font>
2765                        end procedure;
2766                    
2767                    
2768                        procedure CAN_compare_frames(
2769                            constant frame_A        : in    SW_CAN_frame_type;
2770                            constant frame_B        : in    SW_CAN_frame_type;
2771                            constant comp_ts        : in    boolean;
2772                            variable outcome        : inout boolean
2773                        )is
2774                        begin
2775       1/1                  outcome := true;
2776                    
2777       1/1                  if (frame_A.frame_format /= frame_B.frame_format) then
2778       1/1                      info_m(&quot;Frame format (FDF) mismatch A: &quot; &amp;
2779                                      std_logic'image(frame_A.frame_format) &amp; &quot; B: &quot; &amp;
2780                                      std_logic'image(frame_B.frame_format));
2781       1/1                      outcome := false;
2782                            end if;
2783                    
2784       1/1                  if (frame_A.ident_type /= frame_B.ident_type) then
2785       1/1                      info_m(&quot;Identifier type (IDE) mismatch A: &quot; &amp;
2786                                      std_logic'image(frame_A.ident_type) &amp; &quot; B: &quot; &amp;
2787                                      std_logic'image(frame_B.ident_type));
2788       1/1                      outcome := false;
2789                            end if;
2790                    
2791                            -- RTR should be te same only in normal CAN Frame. In FD Frame there is
2792                            -- no RTR bit!
2793       1/1                  if (frame_A.frame_format = NORMAL_CAN) then
2794       1/1                      if (frame_A.rtr /= frame_B.rtr) then
2795       1/1                          info_m(&quot;Remote transmission request (RTR) mismatch&quot;);
2796       1/1                          outcome := false;
2797                                end if;
2798                            end if;
2799                    
2800                            -- BRS bit is compared only in FD frame
2801       1/1                  if (frame_A.frame_format = FD_CAN) then
2802       1/1                      if (frame_A.brs /= frame_B.brs) then
2803       1/1                          info_m(&quot;Bit-rate shift (BRS) mismatch A: &quot; &amp;
2804                                      std_logic'image(frame_A.brs) &amp; &quot; B: &quot; &amp;
2805                                      std_logic'image(frame_B.brs));
2806       1/1                          outcome := false;
2807                                end if;
2808                            end if;
2809                    
2810                            -- Received word count
2811       1/1                  if (frame_A.rwcnt /= frame_B.rwcnt) then
2812       1/1                      info_m(&quot;Read word count (RWCNT) mismatch A: &quot; &amp;
2813                                      integer'image(frame_A.rwcnt) &amp; &quot; B: &quot; &amp;
2814                                      integer'image(frame_B.rwcnt));
2815       1/1                      outcome := false;
2816                            end if;
2817                    
2818                            -- DLC comparison
2819       1/1                  if (frame_A.dlc /= frame_B.dlc) then
2820       1/1                      info_m(&quot;Data length code (DLC) mismatch A: &quot; &amp;
2821                                      to_hstring(frame_A.dlc) &amp; &quot; B: &quot; &amp;
2822                                      to_hstring(frame_B.dlc));
2823       1/1                      outcome := false;
2824                            end if;
2825                    
2826       1/1                  if (frame_A.identifier /= frame_B.identifier) then
2827       1/1                      info_m(&quot;Identifier mismatch A: &quot; &amp; integer'image(frame_A.identifier) &amp;
2828                                     &quot; B: &quot; &amp; integer'image(frame_B.identifier));
2829       1/1                      outcome := false;
2830                            end if;
2831                    
2832                            -- Compare data for NON-RTR Frames. To save time comparing frames whose
2833                            -- metadata comparison failed, do it only for frames which are fine till
2834                            -- now.
2835       1/1                  if (outcome = true) then
2836       1/1                      if ((frame_A.rtr = NO_RTR_FRAME or frame_A.frame_format = FD_CAN)
2837                                    and frame_A.data_length /= 0)
2838                                then
2839       1/1                          for i in 0 to (frame_A.data_length - 1) loop
2840       1/1                              if (frame_A.data(i) /= frame_B.data(i)) then
2841       <font color = "red">0/1     ==>                          info_m(&quot;Data byte: &quot; &amp; integer'image(i) &amp; &quot; mismatch!&quot;);</font>
2842       <font color = "red">0/1     ==>                          outcome  := false;</font>
2843                                        end if;
2844                                    end loop;
2845                                end if;
2846                            end if;
2847                        end procedure;
2848                    
2849                    
2850                        procedure CAN_insert_TX_frame(
2851                            constant frame          : in    SW_CAN_frame_type;
2852                            constant buf_nr         : in    SW_TXT_index_type;
2853                            constant node           : in    t_feature_node;
2854                            signal   channel        : inout t_com_channel;
2855                            constant byte_access    : in    boolean := false
2856                        )is
2857                            variable w_data         :       std_logic_vector(31 downto 0) :=
2858                                                            (OTHERS =&gt; '0');
2859                            variable ident_vect     :       std_logic_vector(28 downto 0) :=
2860                                                            (OTHERS =&gt; '0');
2861                            variable length         :       natural;
2862                            variable buf_offset     :       std_logic_vector(11 downto 0);
2863                        begin
2864                            -- Set Buffer address
2865       1/1                  case buf_nr is
2866       1/1                  when 1 =&gt; buf_offset := TXTB1_DATA_1_ADR;
2867       1/1                  when 2 =&gt; buf_offset := TXTB2_DATA_1_ADR;
2868       1/1                  when 3 =&gt; buf_offset := TXTB3_DATA_1_ADR;
2869       1/1                  when 4 =&gt; buf_offset := TXTB4_DATA_1_ADR;
2870       1/1                  when 5 =&gt; buf_offset := TXTB5_DATA_1_ADR;
2871       1/1                  when 6 =&gt; buf_offset := TXTB6_DATA_1_ADR;
2872       1/1                  when 7 =&gt; buf_offset := TXTB7_DATA_1_ADR;
2873       1/1                  when 8 =&gt; buf_offset := TXTB8_DATA_1_ADR;
2874                            when others =&gt;
2875       <font color = "red">0/1     ==>              error_m(&quot;Unsupported TX buffer number&quot;);</font>
2876                            end case;
2877                    
2878                            -- Frame format word
2879       1/1                  w_data                      := (OTHERS =&gt; '0');
2880       1/1                  w_data(DLC_H downto DLC_L)  := frame.dlc;
2881       1/1                  w_data(RTR_IND)             := frame.rtr;
2882       1/1                  w_data(IDE_IND)             := frame.ident_type;
2883       1/1                  w_data(FDF_IND)             := frame.frame_format;
2884       1/1                  w_data(BRS_IND)             := frame.brs;
2885       1/1                  w_data(ESI_RSV_IND)         := '0'; -- ESI is receive only
2886       1/1                  if (byte_access) then
2887       1/1                      CAN_write_by_byte(w_data, buf_offset, node, channel);
2888                            else
2889       1/1                      CAN_write(w_data, buf_offset, node, channel);
2890                            end if;
2891                    
2892                            -- Identifier
2893       1/1                  id_sw_to_hw(frame.identifier, frame.ident_type, ident_vect);
2894       1/1                  w_data := &quot;000&quot; &amp; ident_vect;
2895                    
2896       1/1                  if (byte_access) then
2897       1/1                      CAN_write_by_byte(w_data, CAN_add_unsigned(buf_offset, IDENTIFIER_W_ADR), node, channel);
2898                            else
2899       1/1                      CAN_write(w_data, CAN_add_unsigned(buf_offset, IDENTIFIER_W_ADR), node, channel);
2900                            end if;
2901                    
2902                            -- Timestamp
2903       1/1                  w_data := frame.timestamp(31 downto 0);
2904       1/1                  if (byte_access) then
2905       1/1                      CAN_write_by_byte(w_data, CAN_add_unsigned(buf_offset, TIMESTAMP_L_W_ADR), node, channel);
2906                            else
2907       1/1                      CAN_write(w_data, CAN_add_unsigned(buf_offset, TIMESTAMP_L_W_ADR), node, channel);
2908                            end if;
2909                    
2910       1/1                  w_data := frame.timestamp(63 downto 32);
2911       1/1                  if (byte_access) then
2912       1/1                      CAN_write_by_byte(w_data, CAN_add_unsigned(buf_offset, TIMESTAMP_U_W_ADR), node, channel);
2913                            else
2914       1/1                      CAN_write(w_data, CAN_add_unsigned(buf_offset, TIMESTAMP_U_W_ADR), node, channel);
2915                            end if;
2916                    
2917                            -- Data words
2918       1/1                  decode_dlc(frame.dlc, length);
2919       1/1                  for i in 0 to (length - 1) / 4 loop
2920       1/1                      w_data := frame.data((i * 4) + 3) &amp;
2921                                          frame.data((i * 4) + 2) &amp;
2922                                          frame.data((i * 4) + 1) &amp;
2923                                          frame.data((i * 4));
2924       1/1                      if (byte_access) then
2925       1/1                          CAN_write_by_byte(w_data, std_logic_vector(unsigned(buf_offset) +
2926                                                      unsigned(DATA_1_4_W_ADR) + i * 4), node, channel);
2927                                else
2928       1/1                          CAN_write(w_data, std_logic_vector(unsigned(buf_offset) +
2929                                                      unsigned(DATA_1_4_W_ADR) + i * 4), node, channel);
2930                                end if;
2931                            end loop;
2932                        end procedure;
2933                    
2934                    
2935                        procedure CAN_set_frame_test(
2936                            constant buf_nr         : in    SW_TXT_index_type;
2937                            constant tprm           : in    natural range 0 to 31;
2938                            constant fstc           : in    boolean;
2939                            constant fcrc           : in    boolean;
2940                            constant sdlc           : in    boolean;
2941                            constant node           : in    t_feature_node;
2942                            signal   channel        : inout t_com_channel
2943                        ) is
2944                            variable w_data         :       std_logic_vector(31 downto 0) :=
2945                                                            (OTHERS =&gt; '0');
2946                            variable buf_offset     :       std_logic_vector(11 downto 0);
2947                        begin
2948                    
2949                            -- Set Buffer address
2950       1/1                  case buf_nr is
2951       1/1                  when 1 =&gt; buf_offset := TXTB1_DATA_1_ADR;
2952       1/1                  when 2 =&gt; buf_offset := TXTB2_DATA_1_ADR;
2953       1/1                  when 3 =&gt; buf_offset := TXTB3_DATA_1_ADR;
2954       1/1                  when 4 =&gt; buf_offset := TXTB4_DATA_1_ADR;
2955       1/1                  when 5 =&gt; buf_offset := TXTB5_DATA_1_ADR;
2956       1/1                  when 6 =&gt; buf_offset := TXTB6_DATA_1_ADR;
2957       1/1                  when 7 =&gt; buf_offset := TXTB7_DATA_1_ADR;
2958       1/1                  when 8 =&gt; buf_offset := TXTB8_DATA_1_ADR;
2959                            when others =&gt;
2960       <font color = "red">0/1     ==>              error_m(&quot;Unsupported TX buffer number&quot;);</font>
2961                            end case;
2962                    
2963       1/1                  w_data := (others =&gt; '0');
2964                    
2965       1/1                  w_data(TPRM_H downto TPRM_L) := std_logic_vector(to_unsigned(tprm, 5));
2966                    
2967       1/1                  if (fstc) then
2968       1/1                      w_data(FSTC_IND) := '1';
2969                            end if;
2970                    
2971       1/1                  if (fcrc) then
2972       1/1                      w_data(FCRC_IND) := '1';
2973                            end if;
2974                    
2975       1/1                  if (sdlc) then
2976       1/1                      w_data(SDLC_IND) := '1';
2977                            end if;
2978                    
2979       1/1                  CAN_write(w_data, CAN_add_unsigned(buf_offset, FRAME_TEST_W_ADR), node, channel);
2980                    
2981                        end procedure;
2982                    
2983                    
2984                        procedure CAN_send_frame(
2985                            constant frame          : in    SW_CAN_frame_type;
2986                            constant buf_nr         : in    SW_TXT_index_type;
2987                            constant node           : in    t_feature_node;
2988                            signal   channel        : inout t_com_channel;
2989                            variable outcome        : out   boolean
2990                        )is
2991                            variable buf_state      :       SW_TXT_Buffer_state_type;
2992                        begin
2993       1/1                  outcome     := true;
2994                    
2995                            -- Read Status of TXT Buffer.
2996       1/1                  get_tx_buf_state(buf_nr, buf_state, node, channel);
2997                    
2998                            -- If TXT Buffer was already locked -&gt; Fail to insert and transmitt!
2999       1/1                  if (buf_state = buf_tx_progress or
3000                                buf_state = buf_ab_progress or
3001                                buf_state = buf_ready)
3002                            then
3003       <font color = "red">0/1     ==>              error_m(&quot;Unable to send the frame, TXT buffer is READY, &quot; &amp;</font>
3004                                      &quot;TX is in progress, or Abort is in progress&quot;);
3005       <font color = "red">0/1     ==>              outcome     := false;</font>
3006       <font color = "red">0/1     ==>              return;</font>
3007                            end if;
3008                    
3009                            -- Insert frame to TXT Buffer
3010       1/1                  CAN_insert_TX_frame(frame, buf_nr, node, channel);
3011                    
3012                            -- Give &quot;Set ready&quot; command to the buffer
3013       1/1                  send_TXT_buf_cmd(buf_set_ready, buf_nr, node, channel);
3014                        end procedure;
3015                    
3016                    
3017                        procedure CAN_read_frame(
3018                            variable frame          : inout SW_CAN_frame_type;
3019                            constant node           : in    t_feature_node;
3020                            signal   channel        : inout t_com_channel;
3021                            constant automatic_mode : in    boolean := true
3022                        )is
3023                            variable r_data         :       std_logic_vector(31 downto 0) :=
3024                                                            (OTHERS =&gt; '0');
3025                            variable aux_vect       :       std_logic_vector(28 downto 0) :=
3026                                                            (OTHERS =&gt; '0');
3027                            variable burst_data     :       std_logic_vector(127 downto 0) :=
3028                                                                (OTHERS =&gt; '0');
3029                            variable frm_fmt_word   :       std_logic_vector(31 downto 0) :=
3030                                                                (OTHERS =&gt; '0');
3031                            variable ident_word     :       std_logic_vector(31 downto 0) :=
3032                                                                (OTHERS =&gt; '0');
3033                            variable ts_low_word    :       std_logic_vector(31 downto 0) :=
3034                                                                (OTHERS =&gt; '0');
3035                            variable ts_high_word   :       std_logic_vector(31 downto 0) :=
3036                                                                (OTHERS =&gt; '0');
3037                            constant burst_access   :       boolean := true;
3038                            variable command        :       SW_command := SW_command_rst_val;
3039                    
3040                        begin
3041                    
3042       1/1                  if (automatic_mode) then
3043                                -- If Burst access is executed read first 4 words all at once!
3044       1/1                      if (burst_access) then
3045       1/1                          CAN_read(burst_data, RX_DATA_ADR, node, channel, true);
3046       1/1                          frm_fmt_word := burst_data(31 downto 0);
3047       1/1                          ident_word   := burst_data(63 downto 32);
3048       1/1                          ts_low_word  := burst_data(95 downto 64);
3049       1/1                          ts_high_word := burst_data(127 downto 96);
3050                    
3051                                else
3052       <font color = "red">0/1     ==>                  CAN_read(frm_fmt_word, RX_DATA_ADR, node, channel);</font>
3053       <font color = "red">0/1     ==>                  CAN_read(ident_word, RX_DATA_ADR, node, channel);</font>
3054       <font color = "red">0/1     ==>                  CAN_read(ts_low_word, RX_DATA_ADR, node, channel);</font>
3055       <font color = "red">0/1     ==>                  CAN_read(ts_high_word, RX_DATA_ADR, node, channel);</font>
3056                                end if;
3057                            else
3058                                -- Use 8-bit accesses to prove multiple accesses can be done without
3059                                -- side effect!
3060       1/1                      command.rx_buf_rdptr_move := true;
3061                    
3062                                -- Frame format word
3063       1/1                      CAN_read_by_byte(frm_fmt_word, RX_DATA_ADR, node, channel);
3064       1/1                      give_controller_command(command, node, channel);
3065                    
3066                                -- Identifier word
3067       1/1                      CAN_read_by_byte(ident_word, RX_DATA_ADR, node, channel);
3068       1/1                      give_controller_command(command, node, channel);
3069                    
3070                                -- Timestamp low word
3071       1/1                      CAN_read_by_byte(ts_low_word, RX_DATA_ADR, node, channel);
3072       1/1                      give_controller_command(command, node, channel);
3073                    
3074       1/1                      CAN_read_by_byte(ts_high_word, RX_DATA_ADR, node, channel);
3075       1/1                      give_controller_command(command, node, channel);
3076                            end if;
3077                    
3078                            -- Parse frame format word
3079       1/1                  frame.dlc           := frm_fmt_word(DLC_H downto DLC_L);
3080       1/1                  frame.rtr           := frm_fmt_word(RTR_IND);
3081       1/1                  frame.ident_type    := frm_fmt_word(IDE_IND);
3082       1/1                  frame.frame_format  := frm_fmt_word(FDF_IND);
3083       1/1                  frame.brs           := frm_fmt_word(BRS_IND);
3084       1/1                  frame.rwcnt         := to_integer(unsigned(
3085                                                   frm_fmt_word(RWCNT_H downto RWCNT_L)));
3086       1/1                  decode_dlc(frame.dlc, frame.data_length);
3087                    
3088                            -- Parse ID
3089       1/1                  aux_vect := ident_word(28 downto 0);
3090       1/1                  id_hw_to_sw(aux_vect, frame.ident_type, frame.identifier);
3091                    
3092                            -- Timestamp
3093       1/1                  frame.timestamp(31 downto 0)  := ts_low_word;
3094       1/1                  frame.timestamp(63 downto 32) := ts_high_word;
3095                    
3096                    
3097                            -- Now read data frames
3098       1/1                  if ((frame.rtr = NO_RTR_FRAME or frame.frame_format = FD_CAN)
3099                                 and frame.data_length /= 0)
3100                            then
3101       1/1                      for i in 0 to (frame.data_length - 1) / 4 loop
3102       1/1                          if (automatic_mode) then
3103       1/1                              CAN_read(r_data, RX_DATA_ADR, node, channel);
3104                                    else
3105       1/1                              CAN_read_by_byte(r_data, RX_DATA_ADR, node, channel);
3106       1/1                              give_controller_command(command, node, channel);
3107                                    end if;
3108       1/1                          frame.data(i * 4)       := r_data(7 downto 0);
3109       1/1                          frame.data((i * 4) + 1) := r_data(15 downto 8);
3110       1/1                          frame.data((i * 4) + 2) := r_data(23 downto 16);
3111       1/1                          frame.data((i * 4) + 3) := r_data(31 downto 24);
3112                                end loop;
3113                            end if;
3114                        end procedure;
3115                    
3116                    
3117                        procedure CAN_wait_frame_sent(
3118                            constant node           : in    t_feature_node;
3119                            signal   channel        : inout t_com_channel
3120                        )is
3121                            variable r_data         :       std_logic_vector(31 downto 0) :=
3122                                                            (OTHERS =&gt; '0');
3123                        begin
3124                            -- Wait until Base ID
3125       1/1                  CAN_wait_pc_state(pc_deb_arbitration, node, channel);
3126                    
3127                            -- Wait until Intermission
3128       1/1                  CAN_wait_pc_state(pc_deb_intermission, node, channel);
3129                        end procedure;
3130                    
3131                    
3132                        procedure CAN_wait_bus_idle(
3133                            constant node           : in    t_feature_node;
3134                            signal   channel        : inout t_com_channel
3135                        )is
3136                            variable r_data         :       std_logic_vector(31 downto 0) :=
3137                                                            (OTHERS =&gt; '0');
3138                        begin
3139       1/1                  info_m(&quot;Waiting till bus idle in node: &quot; &amp; t_feature_node'image(node));
3140       1/1                  mem_bus_agent_disable_transaction_reporting(channel);
3141                    
3142       1/1                  CAN_read(r_data, STATUS_ADR, node, channel);
3143       1/1                  while (r_data(IDLE_IND) = '0') loop
3144       1/1                      CAN_read(r_data, STATUS_ADR, node, channel);
3145                            end loop;
3146                    
3147       1/1                  info_m(&quot;Done&quot;);
3148       1/1                  mem_bus_agent_enable_transaction_reporting(channel);
3149                        end procedure;
3150                    
3151                    
3152                        procedure CAN_wait_error_frame(
3153                            constant node           : in    t_feature_node;
3154                            signal   channel        : inout t_com_channel
3155                        )is
3156                            variable r_data         :       std_logic_vector(31 downto 0) :=
3157                                                            (OTHERS =&gt; '0');
3158                        begin
3159       1/1                  info_m(&quot;Waiting till error frame in node: &quot; &amp; t_feature_node'image(node));
3160       1/1                  mem_bus_agent_disable_transaction_reporting(channel);
3161                    
3162                            -- Wait until unit starts to transmitt or recieve
3163       1/1                  CAN_read(r_data, STATUS_ADR, node, channel);
3164       1/1                  while (r_data(RXS_IND) = '0' and r_data(TXS_IND) = '0') loop
3165       1/1                      CAN_read(r_data, STATUS_ADR, node, channel);
3166                            end loop;
3167                    
3168                            -- Wait until error frame is not being transmitted
3169       1/1                  CAN_read(r_data, STATUS_ADR, node, channel);
3170       1/1                  while (r_data(EFT_IND) = '0') loop
3171       1/1                      CAN_read(r_data, STATUS_ADR, node, channel);
3172                            end loop;
3173                    
3174       1/1                  info_m(&quot;Done&quot;);
3175       1/1                  mem_bus_agent_enable_transaction_reporting(channel);
3176                        end procedure;
3177                    
3178                    
3179                        procedure CAN_wait_n_bits(
3180                            constant bits           : in    natural;
3181                            constant nominal        : in    boolean;
3182                            constant node           : in    t_feature_node;
3183                            signal   channel        : inout t_com_channel
3184                        )is
3185                            variable bus_timing     :       bit_time_config_type;
3186                            variable wait_time      :       integer := 0;
3187                        begin
3188                            -- Read config of the node
3189       <font color = "red">0/1     ==>          CAN_read_timing_v(bus_timing, node, channel);</font>
3190                    
3191                            -- Calculate number of clock cycles to wait
3192       <font color = "red">0/1     ==>          if (nominal) then</font>
3193       <font color = "red">0/1     ==>              wait_time := bus_timing.tq_nbt *</font>
3194                                                (bus_timing.prop_nbt + bus_timing.ph1_nbt +
3195                                                 bus_timing.ph2_nbt + 1);
3196                            else
3197       <font color = "red">0/1     ==>              wait_time := bus_timing.tq_dbt *</font>
3198                                                (bus_timing.prop_dbt + bus_timing.ph1_dbt +
3199                                                 bus_timing.ph2_dbt + 1);
3200                            end if;
3201                    
3202                            -- Check Minimal Bit time
3203       <font color = "red">0/1     ==>          check_m(wait_time &gt; 6, &quot;Calculated Bit Time shorter than minimal!&quot;);</font>
3204                    
3205                            -- Count number of bits to wait
3206                            -- Reading config took some time too, correct &quot;wait_time&quot; by 4 cycles
3207       <font color = "red">0/1     ==>          wait_time := wait_time * bits;</font>
3208       <font color = "red">0/1     ==>          wait_time := wait_time - 4;</font>
3209                    
3210                            -- Wait for calculated amount of clock cycles!
3211       <font color = "red">0/1     ==>          for i in 0 to wait_time - 1 loop</font>
3212       <font color = "red">0/1     ==>              clk_agent_wait_cycle(channel);</font>
3213                            end loop;
3214                        end procedure;
3215                    
3216                    
3217                        procedure CAN_wait_tx_rx_start(
3218                            constant exit_trans     : in    boolean;
3219                            constant exit_rec       : in    boolean;
3220                            constant node           : in    t_feature_node;
3221                            signal   channel        : inout t_com_channel
3222                        )is
3223                            variable r_data         :       std_logic_vector(31 downto 0);
3224                        begin
3225                            -- Wait until unit starts to transmitt or recieve
3226       1/1                  info_m(&quot;Waiting till TX/RX of frame starts in node: &quot; &amp;
3227                                    t_feature_node'image(node));
3228       1/1                  mem_bus_agent_disable_transaction_reporting(channel);
3229                    
3230       1/1                  while (true) loop
3231       1/1                      CAN_read(r_data, STATUS_ADR, node, channel);
3232       1/1                      if (exit_trans and r_data(TXS_IND) = '1') then
3233       1/1                          exit;
3234                                end if;
3235       1/1                      if (exit_rec and r_data(RXS_IND) = '1') then
3236       1/1                          exit;
3237                                end if;
3238                            end loop;
3239                    
3240       1/1                  mem_bus_agent_disable_transaction_reporting(channel);
3241       1/1                  info_m(&quot;Done&quot;);
3242                        end procedure;
3243                    
3244                    
3245                        procedure CAN_wait_bus_on(
3246                            constant node           : in    t_feature_node;
3247                            signal   channel        : inout t_com_channel
3248                        )is
3249                            variable fault_state    :       SW_fault_state;
3250                        begin
3251       1/1                  info_m(&quot;Waiting till bus is on in node: &quot; &amp; t_feature_node'image(node));
3252       1/1                  mem_bus_agent_disable_transaction_reporting(channel);
3253                    
3254       1/1                  get_fault_state(fault_state, node, channel);
3255       1/1                  while (fault_state /= fc_error_active) loop
3256       1/1                      get_fault_state(fault_state, node, channel);
3257       1/1                      wait for 200 ns;
3258                            end loop;
3259                    
3260       1/1                  mem_bus_agent_enable_transaction_reporting(channel);
3261       1/1                  info_m(&quot;Bus on in node: &quot; &amp; t_feature_node'image(node));
3262                        end procedure;
3263                    
3264                    
3265                        procedure CAN_calc_frame_length(
3266                            constant frame          : in    SW_CAN_frame_type;
3267                            variable bit_length     : inout natural
3268                        )is
3269                            variable aux            :       std_logic_vector(1 downto 0);
3270                            variable data_length    :       natural;
3271                        begin
3272       <font color = "red">0/1     ==>          decode_dlc(frame.dlc, data_length);</font>
3273       <font color = "red">0/1     ==>          if (frame.rtr = RTR_FRAME and frame.frame_format = NORMAL_CAN) then</font>
3274       <font color = "red">0/1     ==>              data_length := 0;</font>
3275                            end if;
3276                    
3277                            -- Join the ident type and frame type
3278       <font color = "red">0/1     ==>          aux:= frame.ident_type &amp; frame.frame_format;</font>
3279                    
3280                            -- Calculated identifer and control length
3281       <font color = "red">0/1     ==>          case aux is</font>
3282                            when &quot;00&quot; =&gt;
3283       <font color = "red">0/1     ==>              bit_length := 18;</font>
3284                            when &quot;01&quot; =&gt;
3285       <font color = "red">0/1     ==>              bit_length := 23;</font>
3286                            when &quot;10&quot; =&gt;
3287       <font color = "red">0/1     ==>              bit_length := 39;</font>
3288                            when &quot;11&quot; =&gt;
3289       <font color = "red">0/1     ==>              bit_length := 41;</font>
3290                            when others =&gt;
3291                            end case;
3292                    
3293                            -- Add the data length field
3294       <font color = "red">0/1     ==>          bit_length := bit_length + data_length;</font>
3295                    
3296                            -- Add CRC
3297       <font color = "red">0/1     ==>          if (data_length &lt; 9) then</font>
3298       <font color = "red">0/1     ==>              bit_length := bit_length + 15;</font>
3299                            elsif (data_length &lt; 17) then
3300       <font color = "red">0/1     ==>              bit_length := bit_length + 17;</font>
3301                            else
3302       <font color = "red">0/1     ==>              bit_length := bit_length + 21;</font>
3303                            end if;
3304                    
3305                            -- Add CRC delimiter, Acknowledge and Acknowledge delimiter
3306       <font color = "red">0/1     ==>          bit_length := bit_length + 3;</font>
3307                        end procedure;
3308                    
3309                    
3310                        procedure send_TXT_buf_cmd(
3311                            constant cmd            : in    SW_TXT_Buffer_command_type;
3312                            constant buf_n          : in    SW_TXT_index_type;
3313                            constant node           : in    t_feature_node;
3314                            signal   channel        : inout t_com_channel
3315                        )is
3316                            variable data           :         std_logic_vector(31 downto 0)
3317                                                                := (OTHERS =&gt; '0');
3318                        begin
3319                            -- Set active command bit in TX_COMMAND register based on input command
3320       1/1                  data(TXCE_IND) := '0';
3321       1/1                  data(TXCR_IND) := '0';
3322       1/1                  data(TXCA_IND) := '0';
3323       1/1                  if (cmd = buf_set_empty) then
3324       1/1                      data(TXCE_IND) := '1';
3325                            elsif (cmd = buf_set_ready) then
3326       1/1                      data(TXCR_IND) := '1';
3327                            elsif (cmd = buf_set_abort) then
3328       1/1                      data(TXCA_IND) := '1';
3329                            end if;
3330                    
3331                            -- Set index of Buffer on which the command should be executed.
3332       1/1                  data(buf_n + TXB1_IND - 1) := '1';
3333                    
3334                            -- Give the command
3335       1/1                  CAN_write(data, TX_COMMAND_ADR, node, channel);
3336                        end procedure;
3337                    
3338                    
3339                        procedure send_TXT_buf_cmd(
3340                            constant cmd            : in    SW_TXT_Buffer_command_type;
3341                            constant buf_vector     : in    std_logic_vector(7 downto 0);
3342                            constant node           : in    t_feature_node;
3343                            signal   channel        : inout t_com_channel
3344                        )is
3345                            variable data           :         std_logic_vector(31 downto 0)
3346                                                                := (OTHERS =&gt; '0');
3347                        begin
3348                            -- Set active command bit in TX_COMMAND register based on input command
3349       1/1                  data(TXCE_IND) := '0';
3350       1/1                  data(TXCR_IND) := '0';
3351       1/1                  data(TXCA_IND) := '0';
3352       1/1                  if (cmd = buf_set_empty) then
3353       <font color = "red">0/1     ==>              data(TXCE_IND) := '1';</font>
3354                            elsif (cmd = buf_set_ready) then
3355       1/1                      data(TXCR_IND) := '1';
3356                            elsif (cmd = buf_set_abort) then
3357       <font color = "red">0/1     ==>              data(TXCA_IND) := '1';</font>
3358                            end if;
3359                    
3360                            -- Set index of Buffer on which the command should be executed.
3361       1/1                  for i in 0 to 7 loop
3362       1/1                  	if(buf_vector(i) = '1') then
3363       1/1                  		data(i + TXB1_IND) := '1';
3364                            	end if;
3365                            end loop;
3366                    
3367                            -- Give the command
3368       1/1                  CAN_write(data, TX_COMMAND_ADR, node, channel);
3369                        end procedure;
3370                    
3371                    
3372                        procedure get_tx_buf_state(
3373                            constant buf_n          : in    SW_TXT_index_type;
3374                            variable retVal         : out   SW_TXT_Buffer_state_type;
3375                            constant node           : in    t_feature_node;
3376                            signal   channel        : inout t_com_channel
3377                        )is
3378                            variable data           :       std_logic_vector(31 downto 0);
3379                            variable b_state        :       std_logic_vector(3 downto 0);
3380                            variable buf_index      :       natural range 0 to 7;
3381                        begin
3382       1/1                  CAN_read(data, TX_STATUS_ADR, node, channel);
3383       1/1                  buf_index := buf_n - 1;
3384       1/1                  b_state   := data((buf_index + 1) * 4 - 1 downto buf_index * 4);
3385                    
3386       1/1                  case b_state is
3387       1/1                  when TXT_RDY  =&gt; retVal := buf_ready;
3388       1/1                  when TXT_TRAN =&gt; retVal := buf_tx_progress;
3389       1/1                  when TXT_ABTP =&gt; retVal := buf_ab_progress;
3390       1/1                  when TXT_TOK  =&gt; retVal := buf_done;
3391       1/1                  when TXT_ERR  =&gt; retVal := buf_failed;
3392       1/1                  when TXT_ABT  =&gt; retVal := buf_aborted;
3393       1/1                  when TXT_ETY  =&gt; retVal := buf_empty;
3394       1/1                  when TXT_PER  =&gt; retVal := buf_parity_err;
3395       <font color = "red">0/1     ==>          when TXT_NOT_EXIST =&gt; retVal := buf_not_exist;</font>
3396                            when others =&gt;
3397       <font color = "red">0/1     ==>          error_m(&quot;Invalid TXT Buffer state: &quot; &amp;</font>
3398                                  integer'image(to_integer(unsigned(b_state))));
3399                            end case;
3400                    
3401                        end procedure;
3402                    
3403                    
3404                        procedure get_tx_buf_count(
3405                            variable num_buffers    : out   natural range 1 to 8;
3406                            constant node           : in    t_feature_node;
3407                            signal   channel        : inout t_com_channel
3408                        )is
3409                            variable data           :       std_logic_vector(15 downto 0);
3410                            variable low            :       integer;
3411                            variable high           :       integer;
3412                        begin
3413       1/1                  CAN_read(data, TXTB_INFO_ADR, node, channel);
3414       1/1                  low := TXT_BUFFER_COUNT_L mod 16;
3415       1/1                  high := TXT_BUFFER_COUNT_H mod 16;
3416       1/1                  info_m(&quot;Number of TXT buffers: &quot; &amp; integer'image(
3417                                    to_integer(unsigned(data(high downto low)))));
3418       1/1                  num_buffers := to_integer(unsigned(data(high downto low)));
3419                        end procedure;
3420                    
3421                    
3422                        procedure pick_random_txt_buffer(
3423                            variable txt_buf        : out   SW_TXT_index_type;
3424                            constant node           : in    t_feature_node;
3425                            signal   channel        : inout t_com_channel
3426                        )is
3427                            variable num_buffers : natural range 1 to 8;
3428                            variable tmp : natural;
3429                        begin
3430       1/1                  get_tx_buf_count(num_buffers, node, channel);
3431       1/1                  rand_int_v(num_buffers, tmp);
3432       1/1                  if (tmp = 0) then
3433       1/1                      tmp := 1;
3434                            end if;
3435       1/1                  txt_buf := tmp;
3436       1/1                  check_m(txt_buf &lt;= num_buffers, &quot;Non-existing TXT buffer chosen!&quot;);
3437                        end procedure;
3438                    
3439                    
3440                        procedure get_rx_buf_state(
3441                            variable retVal         : out   SW_RX_Buffer_info;
3442                            constant node           : in    t_feature_node;
3443                            signal   channel        : inout t_com_channel
3444                        )is
3445                            variable data           :       std_logic_vector(31 downto 0);
3446                        begin
3447                            -- Read information about buffer memory first!
3448       1/1                  CAN_read(data, RX_MEM_INFO_ADR, node, channel);
3449       1/1                  retVal.rx_buff_size := to_integer(unsigned(
3450                                                     data(RX_BUFF_SIZE_H downto RX_BUFF_SIZE_L)));
3451       1/1                  retVal.rx_mem_free := to_integer(unsigned(
3452                                                     data(RX_MEM_FREE_H downto RX_MEM_FREE_L)));
3453                    
3454                            -- Read memory pointers
3455       1/1                  CAN_read(data, RX_POINTERS_ADR, node, channel);
3456       1/1                  retVal.rx_write_pointer := to_integer(unsigned(
3457                                                         data(RX_WPP_H downto RX_WPP_L)));
3458       1/1                  retVal.rx_read_pointer  := to_integer(unsigned(
3459                                                         data(RX_RPP_H downto RX_RPP_L)));
3460                    
3461                            -- Read memory status
3462       1/1                  CAN_read(data, RX_STATUS_ADR, node, channel);
3463       1/1                  retVal.rx_full          := false;
3464       1/1                  retVal.rx_empty         := false;
3465       1/1                  retVal.rx_mof           := false;
3466                    
3467       1/1                  if (data(RXF_IND) = '1') then
3468       1/1                      retVal.rx_full      := true;
3469                            end if;
3470                    
3471       1/1                  if (data(RXE_IND) = '1') then
3472       1/1                      retVal.rx_empty     := true;
3473                            end if;
3474                    
3475       1/1                  if (data(RXMOF_IND) = '1') then
3476       1/1                      retVal.rx_mof       := true;
3477                            end if;
3478                    
3479       1/1                  retVal.rx_frame_count   := to_integer(unsigned(
3480                                                        data(RXFRC_H downto RXFRC_L)));
3481                        end procedure;
3482                    
3483                    
3484                        procedure set_rx_buf_options(
3485                            constant options        : in    SW_RX_Buffer_options;
3486                            constant node           : in    t_feature_node;
3487                            signal   channel        : inout t_com_channel
3488                        )is
3489                            variable data : std_logic_vector(7 downto 0) := (OTHERS =&gt; '0');
3490                        begin
3491       1/1                  if (options.rx_time_stamp_options) then
3492       1/1                      data(RTSOP_IND mod 8) := RTS_BEG;
3493                            else
3494       1/1                      data(RTSOP_IND mod 8) := RTS_END;
3495                            end if;
3496                    
3497       1/1                  CAN_write(data, RX_SETTINGS_ADR, node, channel);
3498                        end procedure;
3499                    
3500                    
3501                        procedure get_core_version(
3502                            variable retVal         : out   natural;
3503                            constant node           : in    t_feature_node;
3504                            signal   channel        : inout t_com_channel
3505                        ) is
3506                            variable data           :       std_logic_vector(15 downto 0);
3507                            variable low_major      :       integer;
3508                            variable high_major     :       integer;
3509                            variable low_minor      :       integer;
3510                            variable high_minor     :       integer;
3511                        begin
3512       <font color = "red">0/1     ==>          CAN_read(data, VERSION_ADR, node, channel);</font>
3513                    
3514       <font color = "red">0/1     ==>          low_major := VER_MAJOR_L mod 16;</font>
3515       <font color = "red">0/1     ==>          high_major := VER_MAJOR_H mod 16;</font>
3516       <font color = "red">0/1     ==>          low_minor := VER_MINOR_L mod 16;</font>
3517       <font color = "red">0/1     ==>          high_minor := VER_MINOR_H mod 16;</font>
3518       <font color = "red">0/1     ==>          retVal := (10 * to_integer(unsigned(data(high_major downto low_major)))) +</font>
3519                                      to_integer(unsigned(data(high_minor downto low_minor)));
3520                        end procedure;
3521                    
3522                    
3523                        procedure set_core_mode(
3524                            constant mode           : in    SW_mode;
3525                            constant node           : in    t_feature_node;
3526                            signal   channel        : inout t_com_channel
3527                        )is
3528                            variable data : std_logic_vector(15 downto 0);
3529                        begin
3530       1/1                  data := (OTHERS =&gt; '0');
3531                    
3532                            -- Following modes are stored in MODE register
3533       1/1                  if (mode.reset) then
3534       1/1                      data(RST_IND mod 16)       := '1';
3535                            end if;
3536                    
3537       1/1                  if (mode.bus_monitoring) then
3538       1/1                      data(BMM_IND mod 16)       := '1';
3539                            end if;
3540                    
3541       1/1                  if (mode.self_test) then
3542       1/1                      data(STM_IND mod 16)       := '1';
3543                            end if;
3544                    
3545       1/1                  if (mode.test) then
3546       1/1                      data(TSTM_IND mod 16)      := '1';
3547                            end if;
3548                    
3549       1/1                  if (mode.acceptance_filter) then
3550       1/1                      data(AFM_IND mod 16)       := '1';
3551                            end if;
3552                    
3553       1/1                  if (mode.flexible_data_rate) then
3554       1/1                      data(FDE_IND mod 16)       := '1';
3555                            end if;
3556                    
3557       1/1                  if (mode.restricted_operation) then
3558       1/1                      data(ROM_IND mod 16)       := '1';
3559                            end if;
3560                    
3561       1/1                  if (mode.acknowledge_forbidden) then
3562       1/1                      data(ACF_IND mod 16)       := '1';
3563                            end if;
3564                    
3565       1/1                  if (mode.rx_buffer_automatic) then
3566       1/1                      data(RXBAM_IND mod 16)     := '1';
3567                            end if;
3568                    
3569       1/1                  if (mode.time_triggered_transm) then
3570       1/1                      data(TTTM_IND mod 16)      := '1';
3571                            end if;
3572                    
3573       1/1                  if (mode.tx_buf_backup) then
3574       1/1                      data(TXBBM_IND mod 16)     := '1';
3575                            end if;
3576                    
3577       1/1                  CAN_write(data, MODE_ADR, node, channel);
3578                    
3579                            -- Following modes are stored in SETTINGS register
3580       1/1                  CAN_read(data, SETTINGS_ADR, node, channel);
3581                    
3582       1/1                  if (mode.iso_fd_support) then
3583       1/1                      data(NISOFD_IND mod 16)   := '0';
3584                            else
3585       1/1                      data(NISOFD_IND mod 16)   := '1';
3586                            end if;
3587                    
3588       1/1                  if (mode.internal_loopback) then
3589       1/1                      data(ILBP_IND mod 16)   := '1';
3590                            else
3591       1/1                      data(ILBP_IND mod 16)   := '0';
3592                            end if;
3593                    
3594       1/1                  if (mode.pex_support) then
3595       1/1                      data(PEX_IND mod 16) := '1';
3596                            else
3597       1/1                      data(PEX_IND mod 16) := '0';
3598                            end if;
3599                    
3600       1/1                  if (mode.fdrf) then
3601       1/1                      data(FDRF_IND mod 16) := '1';
3602                            else
3603       1/1                      data(FDRF_IND mod 16) := '0';
3604                            end if;
3605                    
3606       1/1                  if (mode.tx_buf_bus_off_failed) then
3607       1/1                      data(TBFBO_IND mod 16) := '1';
3608                            else
3609       1/1                      data(TBFBO_IND mod 16) := '0';
3610                            end if;
3611                    
3612       1/1                  if (mode.parity_check) then
3613       1/1                      data(PCHKE_IND mod 16) := '1';
3614                            else
3615       1/1                      data(PCHKE_IND mod 16) := '0';
3616                            end if;
3617                    
3618       1/1                  CAN_write(data, SETTINGS_ADR, node, channel);
3619                        end procedure;
3620                    
3621                    
3622                        procedure get_core_mode(
3623                            variable mode           : out   SW_mode;
3624                            constant node           : in    t_feature_node;
3625                            signal   channel        : inout t_com_channel
3626                        )is
3627                            variable data           :       std_logic_vector(31 downto 0);
3628                        begin
3629       1/1                  CAN_read(data, MODE_ADR, node, channel);
3630                    
3631       1/1                  mode.reset                      := false;
3632       1/1                  mode.bus_monitoring             := false;
3633       1/1                  mode.self_test                  := false;
3634       1/1                  mode.acceptance_filter          := false;
3635       1/1                  mode.flexible_data_rate         := false;
3636       1/1                  mode.rtr_pref                   := false;
3637       1/1                  mode.acknowledge_forbidden      := false;
3638       1/1                  mode.test                       := false;
3639       1/1                  mode.fdrf                       := false;
3640       1/1                  mode.restricted_operation       := false;
3641       1/1                  mode.rx_buffer_automatic        := false;
3642       1/1                  mode.time_triggered_transm      := false;
3643       1/1                  mode.tx_buf_backup              := false;
3644       1/1                  mode.parity_check               := false;
3645                    
3646       1/1                  if (data(RST_IND) = '1') then
3647       <font color = "red">0/1     ==>              mode.reset                  := true;</font>
3648                            end if;
3649                    
3650       1/1                  if (data(BMM_IND) = '1') then
3651       1/1                      mode.bus_monitoring         := true;
3652                            end if;
3653                    
3654       1/1                  if (data(STM_IND) = '1') then
3655       1/1                      mode.self_test              := true;
3656                            end if;
3657                    
3658       1/1                  if (data(AFM_IND) = '1') then
3659       <font color = "red">0/1     ==>              mode.acceptance_filter      := true;</font>
3660                            end if;
3661                    
3662       1/1                  if (data(FDE_IND) = '1') then
3663       1/1                      mode.flexible_data_rate     := true;
3664                            end if;
3665                    
3666       1/1                  if (data(ROM_IND) = '1') then
3667       1/1                      mode.restricted_operation   := true;
3668                            end if;
3669                    
3670       1/1                  if (data(ACF_IND) = '1') then
3671       1/1                      mode.acknowledge_forbidden  := true;
3672                            end if;
3673                    
3674       1/1                  if (data(TSTM_IND) = '1') then
3675       1/1                      mode.test                   := true;
3676                            end if;
3677                    
3678       1/1                  if (data(RXBAM_IND) = '1') then
3679       1/1                      mode.rx_buffer_automatic    := true;
3680                            end if;
3681                    
3682       1/1                  if (data(TTTM_IND) = '1') then
3683       1/1                      mode.time_triggered_transm  := true;
3684                            end if;
3685                    
3686       1/1                  if (data(TXBBM_IND) = '1') then
3687       1/1                      mode.tx_buf_backup          := true;
3688                            end if;
3689                    
3690                    
3691                            -- SETTINGs part of read data
3692                    
3693       1/1                  if (data(NISOFD_IND) = '0') then
3694       1/1                      mode.iso_fd_support         := true;
3695                            else
3696       <font color = "red">0/1     ==>              mode.iso_fd_support         := false;</font>
3697                            end if;
3698                    
3699       1/1                  if (data(ILBP_IND) = '1') then
3700       <font color = "red">0/1     ==>              mode.internal_loopback      := true;</font>
3701                            else
3702       1/1                      mode.internal_loopback      := false;
3703                            end if;
3704                    
3705       1/1                  if (data(PEX_IND) = '1') then
3706       1/1                      mode.pex_support            := true;
3707                            else
3708       1/1                      mode.pex_support            := false;
3709                            end if;
3710                    
3711       1/1                  if (data(FDRF_IND) = '1') then
3712       <font color = "red">0/1     ==>              mode.fdrf                   := true;</font>
3713                            else
3714       1/1                      mode.fdrf                   := false;
3715                            end if;
3716                    
3717       1/1                  if (data(TBFBO_IND) = '1') then
3718       1/1                      mode.tx_buf_bus_off_failed  := true;
3719                            else
3720       1/1                      mode.tx_buf_bus_off_failed  := false;
3721                            end if;
3722                    
3723       1/1                  if (data(PCHKE_IND) = '1') then
3724       1/1                      mode.parity_check           := true;
3725                            else
3726       1/1                      mode.parity_check           := false;
3727                            end if;
3728                    
3729                        end procedure;
3730                    
3731                    
3732                        procedure exec_SW_reset(
3733                            constant node           : in    t_feature_node;
3734                            signal   channel        : inout t_com_channel
3735                        )is
3736                            variable mode           :       SW_mode;
3737                        begin
3738       1/1                  get_core_mode(mode, node, channel);
3739                    
3740                            -- Note that reset bit is self clearing, no need to write 0 afterwards!
3741       1/1                  mode.reset := true;
3742                    
3743       1/1                  set_core_mode(mode, node, channel);
3744                        end procedure;
3745                    
3746                    
3747                        procedure give_controller_command(
3748                            constant command        : in    SW_command;
3749                            constant node           : in    t_feature_node;
3750                            signal   channel        : inout t_com_channel
3751                        )is
3752                            variable data           :       std_logic_vector(31 downto 0);
3753                        begin
3754       1/1                  data := (OTHERS =&gt; '0');
3755                    
3756       1/1                  if (command.release_rec_buffer) then
3757       1/1                      data(RRB_IND)        := '1';
3758                            end if;
3759                    
3760       1/1                  if (command.clear_data_overrun) then
3761       1/1                      data(CDO_IND)        := '1';
3762                            end if;
3763                    
3764       1/1                  if (command.err_ctrs_rst) then
3765       1/1                      data(ERCRST_IND)     := '1';
3766                            end if;
3767                    
3768       1/1                  if (command.rx_frame_ctr_rst) then
3769       1/1                      data(RXFCRST_IND)    := '1';
3770                            end if;
3771                    
3772       1/1                  if (command.tx_frame_ctr_rst) then
3773       1/1                      data(TXFCRST_IND)    := '1';
3774                            end if;
3775                    
3776       1/1                  if (command.clear_pexs_flag) then
3777       1/1                      data(CPEXS_IND)      := '1';
3778                            end if;
3779                    
3780       1/1                  if (command.rx_buf_rdptr_move) then
3781       1/1                      data(RXRPMV_IND)     := '1';
3782                            end if;
3783                    
3784       1/1                  if (command.clear_rxpe) then
3785       1/1                      data(CRXPE_IND)     := '1';
3786                            end if;
3787                    
3788       1/1                  if (command.clear_txpe) then
3789       1/1                      data(CTXPE_IND)     := '1';
3790                            end if;
3791                    
3792       1/1                  if (command.clear_txdpe) then
3793       1/1                      data(CTXDPE_IND)     := '1';
3794                            end if;
3795                    
3796       1/1                  CAN_write(data, COMMAND_ADR, node, channel);
3797                        end procedure;
3798                    
3799                    
3800                        procedure get_controller_status(
3801                            variable status         : out   SW_status;
3802                            constant node           : in    t_feature_node;
3803                            signal   channel        : inout t_com_channel
3804                        ) is
3805                            variable data           :       std_logic_vector(31 downto 0);
3806                        begin
3807       1/1                  CAN_read(data, STATUS_ADR, node, channel);
3808                    
3809       1/1                  status.receive_buffer           := false;
3810       1/1                  status.data_overrun             := false;
3811       1/1                  status.tx_buffer_empty          := false;
3812       1/1                  status.error_transmission       := false;
3813       1/1                  status.receiver                 := false;
3814       1/1                  status.transmitter              := false;
3815       1/1                  status.error_warning            := false;
3816       1/1                  status.bus_status               := false;
3817       1/1                  status.rx_parity_error          := false;
3818       1/1                  status.tx_parity_error          := false;
3819       1/1                  status.tx_double_parity_error   := false;
3820                    
3821       1/1                  if (data(RXNE_IND) = '1') then
3822       1/1                      status.receive_buffer       := true;
3823                            end if;
3824                    
3825       1/1                  if (data(DOR_IND) = '1') then
3826       1/1                      status.data_overrun         := true;
3827                            end if;
3828                    
3829       1/1                  if (data(TXNF_IND) = '1') then
3830       1/1                      status.tx_buffer_empty      := true;
3831                            end if;
3832                    
3833       1/1                  if (data(EFT_IND) = '1') then
3834       1/1                      status.error_transmission   := true;
3835                            end if;
3836                    
3837       1/1                  if (data(RXS_IND) = '1') then
3838       1/1                      status.receiver             := true;
3839                            end if;
3840                    
3841       1/1                  if (data(TXS_IND) = '1') then
3842       1/1                      status.transmitter          := true;
3843                            end if;
3844                    
3845       1/1                  if (data(EWL_IND) = '1') then
3846       1/1                      status.error_warning        := true;
3847                            end if;
3848                    
3849       1/1                  if (data(IDLE_IND) = '1') then
3850       1/1                      status.bus_status           := true;
3851                            end if;
3852                    
3853       1/1                  if (data(PEXS_IND) = '1') then
3854       1/1                      status.protocol_exception   := true;
3855                            end if;
3856                    
3857       1/1                  if (data(RXPE_IND) = '1') then
3858       1/1                      status.rx_parity_error      := true;
3859                            end if;
3860                    
3861       1/1                  if (data(TXPE_IND) = '1') then
3862       1/1                      status.tx_parity_error      := true;
3863                            end if;
3864                    
3865       1/1                  if (data(TXDPE_IND) = '1') then
3866       1/1                      status.tx_double_parity_error := true;
3867                            end if;
3868                        end procedure;
3869                    
3870                    
3871                        procedure configure_retransmitt_limit(
3872                            constant enable         : in    boolean;
3873                            constant limit          : in    natural range 0 to 15;
3874                            constant node           : in    t_feature_node;
3875                            signal   channel        : inout t_com_channel
3876                        ) is
3877                            variable data : std_logic_vector(15 downto 0);
3878                            variable low : natural := RTRTH_L mod 16;
3879                            variable high : natural := RTRTH_H mod 16;
3880                        begin
3881       <font color = "red">0/1     ==>          CAN_read(data, SETTINGS_ADR, node, channel);</font>
3882                    
3883       <font color = "red">0/1     ==>          if (enable) then</font>
3884       <font color = "red">0/1     ==>              data(RTRLE_IND mod 16) := '1';</font>
3885                            else
3886       <font color = "red">0/1     ==>              data(RTRLE_IND mod 16) := '0';</font>
3887                            end if;
3888                    
3889       <font color = "red">0/1     ==>          data(high downto low) :=</font>
3890                                std_logic_vector(to_unsigned(limit, RTRTH_H - RTRTH_L + 1));
3891                    
3892       <font color = "red">0/1     ==>          CAN_write(data, SETTINGS_ADR, node, channel);</font>
3893                        end procedure;
3894                    
3895                    
3896                        procedure enable_controller(
3897                            constant enable         : in    boolean;
3898                            constant node           : in    t_feature_node;
3899                            signal   channel        : inout t_com_channel
3900                        ) is
3901                            variable data : std_logic_vector(15 downto 0);
3902                        begin
3903       <font color = "red">0/1     ==>          CAN_read(data, SETTINGS_ADR, node, channel);</font>
3904                    
3905       <font color = "red">0/1     ==>          if (enable) then</font>
3906       <font color = "red">0/1     ==>              data(ENA_IND mod 16) := '1';</font>
3907                            else
3908       <font color = "red">0/1     ==>              data(ENA_IND mod 16) := '0';</font>
3909                            end if;
3910                    
3911       <font color = "red">0/1     ==>          CAN_write(data, SETTINGS_ADR, node, channel);</font>
3912                        end procedure;
3913                    
3914                    
3915                        function sw_int_to_int_reg(
3916                            constant interrupts     :       SW_interrupts
3917                        )return std_logic_vector is
3918                            variable tmp            :       std_logic_vector(31 downto 0);
3919                        begin
3920       1/1                  tmp := (OTHERS =&gt; '0');
3921                    
3922       1/1                  if (interrupts.receive_int) then
3923       1/1                      tmp(RXI_IND)        :=  '1';
3924                            end if;
3925                    
3926       1/1                  if (interrupts.transmitt_int) then
3927       1/1                      tmp(TXI_IND)        :=  '1';
3928                            end if;
3929                    
3930       1/1                  if (interrupts.error_warning_int) then
3931       1/1                      tmp(EWLI_IND)       :=  '1';
3932                            end if;
3933                    
3934       1/1                  if (interrupts.data_overrun_int) then
3935       1/1                      tmp(DOI_IND)        :=  '1';
3936                            end if;
3937                    
3938       1/1                  if (interrupts.fcs_changed_int) then
3939       1/1                      tmp(FCSI_IND)       :=  '1';
3940                            end if;
3941                    
3942       1/1                  if (interrupts.arb_lost_int) then
3943       1/1                      tmp(ALI_IND)        :=  '1';
3944                            end if;
3945                    
3946       1/1                  if (interrupts.bus_error_int) then
3947       1/1                      tmp(BEI_IND)        :=  '1';
3948                            end if;
3949                    
3950       1/1                  if (interrupts.rx_buffer_full_int) then
3951       1/1                      tmp(RXFI_IND)       :=  '1';
3952                            end if;
3953                    
3954       1/1                  if (interrupts.bit_rate_shift_int) then
3955       1/1                      tmp(BSI_IND)        :=  '1';
3956                            end if;
3957                    
3958       1/1                  if (interrupts.rx_buffer_not_empty_int) then
3959       1/1                      tmp(RBNEI_IND)      :=  '1';
3960                            end if;
3961                    
3962       1/1                  if (interrupts.tx_buffer_hw_cmd) then
3963       1/1                      tmp(TXBHCI_IND)     :=  '1';
3964                            end if;
3965                    
3966       1/1                  if (interrupts.overload_frame) then
3967       1/1                      tmp(OFI_IND)        := '1';
3968                            end if;
3969                    
3970       1/1                  return tmp;
3971                        end function;
3972                    
3973                    
3974                        function int_reg_to_sw_int(
3975                            constant int_reg        :       std_logic_vector(31 downto 0)
3976                        )return SW_interrupts is
3977                            variable tmp            :       SW_interrupts;
3978                        begin
3979       1/1                  tmp := (false, false, false, false, false, false,
3980                                    false, false, false, false, false, false, false);
3981                    
3982       1/1                  if (int_reg(RXI_IND) = '1') then
3983       1/1                      tmp.receive_int              :=  true;
3984                            end if;
3985                    
3986       1/1                  if (int_reg(TXI_IND) = '1') then
3987       1/1                      tmp.transmitt_int            :=  true;
3988                            end if;
3989                    
3990       1/1                  if (int_reg(EWLI_IND) = '1') then
3991       1/1                      tmp.error_warning_int        :=  true;
3992                            end if;
3993                    
3994       1/1                  if (int_reg(DOI_IND) = '1') then
3995       1/1                      tmp.data_overrun_int         :=  true;
3996                            end if;
3997                    
3998       1/1                  if (int_reg(FCSI_IND) = '1') then
3999       1/1                      tmp.fcs_changed_int          :=  true;
4000                            end if;
4001                    
4002       1/1                  if (int_reg(ALI_IND) = '1') then
4003       1/1                      tmp.arb_lost_int             :=  true;
4004                            end if;
4005                    
4006       1/1                  if (int_reg(BEI_IND) = '1') then
4007       1/1                      tmp.bus_error_int            :=  true;
4008                            end if;
4009                    
4010       1/1                  if (int_reg(RXFI_IND) = '1') then
4011       1/1                      tmp.rx_buffer_full_int       :=  true;
4012                            end if;
4013                    
4014       1/1                  if (int_reg(BSI_IND) = '1') then
4015       1/1                      tmp.bit_rate_shift_int       :=  true;
4016                            end if;
4017                    
4018       1/1                  if (int_reg(RBNEI_IND) = '1') then
4019       1/1                      tmp.rx_buffer_not_empty_int  :=  true;
4020                            end if;
4021                    
4022       1/1                  if (int_reg(TXBHCI_IND) = '1') then
4023       1/1                      tmp.tx_buffer_hw_cmd         :=  true;
4024                            end if;
4025                    
4026       1/1                  if (int_reg(OFI_IND) = '1') then
4027       1/1                      tmp.overload_frame           := true;
4028                            end if;
4029                    
4030       1/1                  return tmp;
4031                        end function;
4032                    
4033                    
4034                        procedure read_int_status(
4035                            variable interrupts     : out   SW_interrupts;
4036                            constant node           : in    t_feature_node;
4037                            signal   channel        : inout t_com_channel
4038                        ) is
4039                            variable data           :       std_logic_vector(31 downto 0);
4040                        begin
4041       1/1                  CAN_read(data, INT_STAT_ADR, node, channel);
4042       1/1                  interrupts := int_reg_to_sw_int(data);
4043                        end procedure;
4044                    
4045                    
4046                        procedure clear_int_status(
4047                            constant interrupts     : in    SW_interrupts;
4048                            constant node           : in    t_feature_node;
4049                            signal   channel        : inout t_com_channel
4050                        ) is
4051                            variable data           :       std_logic_vector(31 downto 0);
4052                        begin
4053       1/1                  data := sw_int_to_int_reg(interrupts);
4054       1/1                  CAN_write(data, INT_STAT_ADR, node, channel);
4055                        end procedure;
4056                    
4057                    
4058                        procedure read_int_enable(
4059                            variable interrupts     : out   SW_interrupts;
4060                            constant node           : in    t_feature_node;
4061                            signal   channel        : inout t_com_channel
4062                        ) is
4063                            variable data           :       std_logic_vector(31 downto 0);
4064                        begin
4065       1/1                  CAN_read(data, INT_ENA_SET_ADR, node, channel);
4066       1/1                  interrupts := int_reg_to_sw_int(data);
4067                        end procedure;
4068                    
4069                    
4070                        procedure write_int_enable(
4071                            constant interrupts     : in    SW_interrupts;
4072                            constant node           : in    t_feature_node;
4073                            signal   channel        : inout t_com_channel
4074                        ) is
4075                            variable data           :       std_logic_vector(31 downto 0);
4076                        begin
4077                            -- Set interrupts which should be set to 1
4078       1/1                  data := sw_int_to_int_reg(interrupts);
4079       1/1                  CAN_write(data, INT_ENA_SET_ADR, node, channel);
4080                    
4081                            -- Clear interrupts which should be set to 0
4082       1/1                  data := not data;
4083       1/1                  CAN_write(data, INT_ENA_CLR_ADR, node, channel);
4084                        end procedure;
4085                    
4086                    
4087                        procedure read_int_mask(
4088                            variable interrupts     : out   SW_interrupts;
4089                            constant node           : in    t_feature_node;
4090                            signal   channel        : inout t_com_channel
4091                        ) is
4092                            variable data           :       std_logic_vector(31 downto 0);
4093                        begin
4094       1/1                  CAN_read(data, INT_MASK_SET_ADR, node, channel);
4095       1/1                  interrupts := int_reg_to_sw_int(data);
4096                        end procedure;
4097                    
4098                    
4099                        procedure write_int_mask(
4100                            constant interrupts     : in    SW_interrupts;
4101                            constant node           : in    t_feature_node;
4102                            signal   channel        : inout t_com_channel
4103                        ) is
4104                            variable data           :       std_logic_vector(31 downto 0);
4105                        begin
4106                            -- Set interrupts which should be set to 1
4107       1/1                  data := sw_int_to_int_reg(interrupts);
4108       1/1                  CAN_write(data, INT_MASK_SET_ADR, node, channel);
4109                    
4110                            -- Clear interrupts which should be set to 0
4111       1/1                  data := not data;
4112       1/1                  CAN_write(data, INT_MASK_CLR_ADR, node, channel);
4113                        end procedure;
4114                    
4115                    
4116                    
4117                        procedure get_fault_state(
4118                            variable fault_state    : out   SW_fault_state;
4119                            constant node           : in    t_feature_node;
4120                            signal   channel        : inout t_com_channel
4121                        ) is
4122                            variable data           :       std_logic_vector(15 downto 0);
4123                        begin
4124       1/1                  CAN_read(data, FAULT_STATE_ADR, node, channel);
4125                    
4126       1/1                  if (data(ERA_IND mod 16) = '1') then
4127       1/1                      fault_state         := fc_error_active;
4128                            elsif (data(ERP_IND mod 16) = '1') then
4129       1/1                      fault_state         := fc_error_passive;
4130                            elsif (data(BOF_IND mod 16) = '1') then
4131       1/1                      fault_state         := fc_bus_off;
4132                            end if;
4133                        end procedure;
4134                    
4135                    
4136                        procedure set_fault_thresholds(
4137                            constant fault_th       : in    SW_fault_thresholds;
4138                            constant node           : in    t_feature_node;
4139                            signal   channel        : inout t_com_channel
4140                        ) is
4141                            variable data : std_logic_vector(7 downto 0) := (OTHERS =&gt; '0');
4142                        begin
4143       1/1                  data((EW_LIMIT_H mod 8) downto (EW_LIMIT_L mod 8)) :=
4144                                std_logic_vector(to_unsigned(fault_th.ewl, 8));
4145       1/1                  CAN_write(data, EWL_ADR, node, channel);
4146                    
4147       1/1                  data((ERP_LIMIT_H mod 8) downto (ERP_LIMIT_L mod 8)) :=
4148                                std_logic_vector(to_unsigned(fault_th.erp, 8));
4149       1/1                  CAN_write(data, ERP_ADR, node, channel);
4150                        end procedure;
4151                    
4152                    
4153                        procedure get_fault_thresholds(
4154                            variable fault_th       : out   SW_fault_thresholds;
4155                            constant node           : in    t_feature_node;
4156                            signal   channel        : inout t_com_channel
4157                        ) is
4158                            variable data : std_logic_vector(7 downto 0) := (OTHERS =&gt; '0');
4159                            variable low : integer;
4160                            variable high : integer;
4161                        begin
4162       1/1                  CAN_read(data, EWL_ADR, node, channel);
4163       1/1                  low := EW_LIMIT_L mod 8;
4164       1/1                  high := EW_LIMIT_H mod 8;
4165       1/1                  fault_th.ewl := to_integer(unsigned(data(high downto low)));
4166                    
4167       1/1                  CAN_read(data, ERP_ADR, node, channel);
4168       1/1                  low := ERP_LIMIT_L mod 8;
4169       1/1                  high := ERP_LIMIT_H mod 8;
4170       1/1                  fault_th.erp := to_integer(unsigned(data(high downto low)));
4171                        end procedure;
4172                    
4173                    
4174                        procedure read_error_counters(
4175                            variable err_counters   : out   SW_error_counters;
4176                            constant node           : in    t_feature_node;
4177                            signal   channel        : inout t_com_channel
4178                        ) is
4179                            variable data           :       std_logic_vector(15 downto 0);
4180                            variable msg            :       line;
4181                        begin
4182                            -- Reading separately for possible future separation of REC and TEC!
4183       1/1                  CAN_read(data, REC_ADR, node, channel);
4184                    
4185       1/1                  err_counters.rx_counter :=
4186                                    to_integer(unsigned(data((REC_VAL_H mod 16) downto
4187                                                             (REC_VAL_L mod 16) )));
4188                    
4189       1/1                  CAN_read(data, TEC_ADR, node, channel);
4190       1/1                  err_counters.tx_counter :=
4191                                    to_integer(unsigned(data((TEC_VAL_H mod 16) downto
4192                                                             (TEC_VAL_L mod 16) )));
4193                    
4194       1/1                  CAN_read(data, ERR_NORM_ADR, node, channel);
4195       1/1                  err_counters.err_norm :=
4196                                    to_integer(unsigned(data((ERR_NORM_VAL_H mod 16) downto
4197                                                             (ERR_NORM_VAL_L mod 16) )));
4198                    
4199       1/1                  CAN_read(data, ERR_FD_ADR, node, channel);
4200       1/1                  err_counters.err_fd :=
4201                                    to_integer(unsigned(data((ERR_FD_VAL_H mod 16) downto
4202                                                             (ERR_FD_VAL_L mod 16) )));
4203                        end procedure;
4204                    
4205                    
4206                        procedure set_test_mem_access(
4207                            constant enable         : in    boolean;
4208                            constant node           : in    t_feature_node;
4209                            signal   channel        : inout t_com_channel
4210                        ) is
4211                            variable mode : SW_mode;
4212                            variable data : std_logic_vector(31 downto 0) := (OTHERS =&gt; '0');
4213                        begin
4214                            -- Check test mode is set, throw error otherwise
4215       1/1                  get_core_mode(mode, node, channel);
4216                    
4217                            -- Enable access
4218       1/1                  if (enable) then
4219       1/1                      data(TMAENA_IND) := '1';
4220                            else
4221       1/1                      data(TMAENA_IND) := '0';
4222                            end if;
4223       1/1                  CAN_write(data, TST_CONTROL_ADR, node, channel);
4224                        end procedure;
4225                    
4226                    
4227                        function tgt_test_mem_to_reg(
4228                            constant tgt_mem        : in  t_tgt_test_mem
4229                        ) return std_logic_vector is
4230                        begin
4231       1/1                  case tgt_mem is
4232                            when TST_TGT_RX_BUF =&gt;
4233       1/1                      return TMTGT_RXBUF;
4234                            when TST_TGT_TXT_BUF_1 =&gt;
4235       1/1                      return TMTGT_TXTBUF1;
4236                            when TST_TGT_TXT_BUF_2 =&gt;
4237       1/1                      return TMTGT_TXTBUF2;
4238                            when TST_TGT_TXT_BUF_3 =&gt;
4239       1/1                      return TMTGT_TXTBUF3;
4240                            when TST_TGT_TXT_BUF_4 =&gt;
4241       1/1                      return TMTGT_TXTBUF4;
4242                            when TST_TGT_TXT_BUF_5 =&gt;
4243       1/1                      return TMTGT_TXTBUF5;
4244                            when TST_TGT_TXT_BUF_6 =&gt;
4245       1/1                      return TMTGT_TXTBUF6;
4246                            when TST_TGT_TXT_BUF_7 =&gt;
4247       1/1                      return TMTGT_TXTBUF7;
4248                            when TST_TGT_TXT_BUF_8 =&gt;
4249       1/1                      return TMTGT_TXTBUF8;
4250                            end case;
4251                        end function;
4252                    
4253                    
4254                        function txt_buf_to_test_mem_tgt(
4255                            constant txt_buf        : in  SW_TXT_index_type
4256                        ) return t_tgt_test_mem is
4257                        begin
4258       1/1                  case txt_buf is
4259       1/1                  when 1 =&gt; return TST_TGT_TXT_BUF_1;
4260       1/1                  when 2 =&gt; return TST_TGT_TXT_BUF_2;
4261       1/1                  when 3 =&gt; return TST_TGT_TXT_BUF_3;
4262       1/1                  when 4 =&gt; return TST_TGT_TXT_BUF_4;
4263       1/1                  when 5 =&gt; return TST_TGT_TXT_BUF_5;
4264       1/1                  when 6 =&gt; return TST_TGT_TXT_BUF_6;
4265       1/1                  when 7 =&gt; return TST_TGT_TXT_BUF_7;
4266       1/1                  when 8 =&gt; return TST_TGT_TXT_BUF_8;
4267                            end case;
4268                        end function;
4269                    
4270                    
4271                        procedure test_mem_write(
4272                            constant data           : in    std_logic_vector(31 downto 0);
4273                            constant address        : in    natural;
4274                            constant tgt_mem        : in    t_tgt_test_mem;
4275                            constant node           : in    t_feature_node;
4276                            signal   channel        : inout t_com_channel;
4277                            constant tmaen          : in    boolean := true
4278                        ) is
4279                            variable data_i : std_logic_vector(31 downto 0) := (OTHERS =&gt; '0');
4280                        begin
4281                            -- Set address
4282       1/1                  data_i(TST_ADDR_H downto TST_ADDR_L) :=
4283                                std_logic_vector(to_unsigned(address, 16));
4284       1/1                  data_i(TST_MTGT_H downto TST_MTGT_L) := tgt_test_mem_to_reg(tgt_mem);
4285       1/1                  CAN_write(data_i, TST_DEST_ADR, node, channel);
4286                    
4287                            -- Set data
4288       1/1                  data_i := data;
4289       1/1                  CAN_write(data_i, TST_WDATA_ADR, node, channel);
4290                    
4291                            -- Execute write
4292       1/1                  data_i := (OTHERS =&gt; '0');
4293       1/1                  if (tmaen) then
4294       1/1                      data_i(TMAENA_IND) := '1';
4295                            else
4296       1/1                      data_i(TMAENA_IND) := '0';
4297                            end if;
4298       1/1                  data_i(TWRSTB_IND) := '1';
4299       1/1                  CAN_write(data_i, TST_CONTROL_ADR, node, channel);
4300                        end procedure;
4301                    
4302                    
4303                        procedure test_mem_read(
4304                            variable data           : out   std_logic_vector(31 downto 0);
4305                            constant address        : in    natural;
4306                            constant tgt_mem        : in    t_tgt_test_mem;
4307                            constant node           : in    t_feature_node;
4308                            signal   channel        : inout t_com_channel
4309                        ) is
4310                            variable data_i : std_logic_vector(31 downto 0) := (OTHERS =&gt; '0');
4311                        begin
4312       1/1                  data_i := (OTHERS =&gt; '0');
4313                            -- Set address
4314       1/1                  data_i(TST_ADDR_H downto TST_ADDR_L) :=
4315                                std_logic_vector(to_unsigned(address, 16));
4316       1/1                  data_i(TST_MTGT_H downto TST_MTGT_L) := tgt_test_mem_to_reg(tgt_mem);
4317       1/1                  CAN_write(data_i, TST_DEST_ADR, node, channel);
4318                    
4319                            -- Wait for one clock cycle
4320       1/1                  clk_agent_wait_cycle(channel);
4321                    
4322                            -- Read data
4323       1/1                  CAN_read(data, TST_RDATA_ADR, node, channel);
4324                        end procedure;
4325                    
4326                    
4327                        function str_equal(
4328                            a : string;
4329                            b : string
4330                        ) return boolean is
4331                            constant len : natural := MINIMUM(a'length, b'length);
4332                            constant atail : string(a'left+len to a'right) := (others =&gt; ' ');
4333                            constant btail : string(b'left+len to b'right) := (others =&gt; ' ');
4334                        begin
4335       <font color = "red">0/1     ==>          return     a(a'left to a'left+len-1) = b(b'left to b'left+len-1)</font>
4336                                   and a(a'left+len to a'right) = atail
4337                                   and b(b'left+len to b'right) = btail;
4338                        end function str_equal;
4339                    
4340                    
4341                        impure function strtolen(
4342                            n : natural;
4343                            src : string
4344                        ) return string is
4345                            variable s : string(1 to n) := (others =&gt; ' ');
4346                        begin
4347       <font color = "red">0/1     ==>          check_m(src'length &lt;= n, &quot;String too long.&quot;);</font>
4348       <font color = "red">0/1     ==>          s(src'range) := src;</font>
4349       <font color = "red">0/1     ==>          return s;</font>
4350                        end function strtolen;
4351                    
4352                    
4353                        procedure set_error_counters(
4354                            constant err_counters   : in    SW_error_counters;
4355                            constant node           : in    t_feature_node;
4356                            signal   channel        : inout t_com_channel
4357                        ) is
4358                            variable data           :       std_logic_vector(15 downto 0);
4359                            variable low            :       integer;
4360                            variable high           :       integer;
4361                        begin
4362       1/1                  data := (OTHERS =&gt; '0');
4363                    
4364                            -- Indices for preset values
4365       1/1                  low := CTPV_L mod 16;
4366       1/1                  high := CTPV_H mod 16;
4367                    
4368                            -- TX Error counter
4369       1/1                  data(high downto low) := std_logic_vector(to_unsigned(
4370                                                        err_counters.tx_counter, 9));
4371       1/1                  data(PTX_IND mod 16) := '1';
4372       1/1                  CAN_write(data, CTR_PRES_ADR, node, channel);
4373       1/1                  data(PTX_IND mod 16) := '0';
4374                    
4375                            -- RX Error counter
4376       1/1                  data(high downto low) := std_logic_vector(to_unsigned(
4377                                                        err_counters.rx_counter, 9));
4378       1/1                  data(PRX_IND mod 16) := '1';
4379       1/1                  CAN_write(data, CTR_PRES_ADR, node, channel);
4380       1/1                  data(PRX_IND mod 16) := '0';
4381                    
4382                            -- Nominal bit rate counter
4383       1/1                  data(high downto low) := std_logic_vector(to_unsigned(
4384                                                        err_counters.err_norm, 9));
4385       1/1                  data(ENORM_IND mod 16) := '1';
4386       1/1                  CAN_write(data, CTR_PRES_ADR, node, channel);
4387       1/1                  data(ENORM_IND mod 16) := '0';
4388                    
4389                            -- Data bit rate counter
4390       1/1                  data(high downto low) := std_logic_vector(to_unsigned(
4391                                                            err_counters.err_fd, 9));
4392       1/1                  data(EFD_IND mod 16) := '1';
4393       1/1                  CAN_write(data, CTR_PRES_ADR, node, channel);
4394       1/1                  data(EFD_IND mod 16) := '0';
4395                        end procedure;
4396                    
4397                    
4398                        procedure read_alc(
4399                            variable alc            : out   natural;
4400                            constant node           : in    t_feature_node;
4401                            signal   channel        : inout t_com_channel
4402                        )is
4403                            variable data           :       std_logic_vector(7 downto 0);
4404                            variable low            :       integer;
4405                            variable high           :       integer;
4406                        begin
4407       1/1                  CAN_read(data, ALC_ADR, node, channel);
4408                    
4409       1/1                  low := ALC_ID_FIELD_L mod 8;
4410       1/1                  high := ALC_ID_FIELD_H mod 8;
4411       1/1                  case data(high downto low) is
4412                            when ALC_BASE_ID =&gt;
4413       1/1                      alc := 11 - to_integer(unsigned(data((ALC_BIT_H mod 8) downto (ALC_BIT_L mod 8))));
4414                            when ALC_EXTENSION =&gt;
4415       1/1                      alc := 31 - to_integer(unsigned(data((ALC_BIT_H mod 8) downto (ALC_BIT_L mod 8))));
4416                            when ALC_SRR_RTR =&gt;
4417       1/1                      alc := 12;
4418                            when ALC_IDE =&gt;
4419       1/1                      alc := 13;
4420                            when ALC_RTR =&gt;
4421       1/1                      alc := 32;
4422                            when ALC_RSVD =&gt;
4423       1/1                      alc := 0;
4424                            when others =&gt;
4425       <font color = "red">0/1     ==>              error_m(&quot;Unsupported ALC type&quot;);</font>
4426                            end case;
4427                    
4428                        end procedure;
4429                    
4430                    
4431                        procedure read_traffic_counters(
4432                            variable ctr            : out   SW_traffic_counters;
4433                            constant node           : in    t_feature_node;
4434                            signal   channel        : inout t_com_channel
4435                        )is
4436                            variable data           :       std_logic_vector(31 downto 0);
4437                        begin
4438       1/1                  CAN_read(data, RX_FR_CTR_ADR, node, channel);
4439       1/1                  ctr.rx_frames := to_integer(unsigned(data(
4440                                                RX_FR_CTR_VAL_H downto RX_FR_CTR_VAL_L)));
4441                    
4442       1/1                  CAN_read(data, TX_FR_CTR_ADR, node, channel);
4443       1/1                  ctr.tx_frames := to_integer(unsigned(data(
4444                                                TX_FR_CTR_VAL_H downto TX_FR_CTR_VAL_L)));
4445                        end procedure;
4446                    
4447                    
4448                        procedure read_trv_delay(
4449                            variable trv_delay      : out   natural;
4450                            constant node           : in    t_feature_node;
4451                            signal   channel        : inout t_com_channel
4452                        )is
4453                            variable data           :       std_logic_vector(31 downto 0);
4454                        begin
4455       1/1                  CAN_read(data, TRV_DELAY_ADR, node, channel);
4456       1/1                  trv_delay := to_integer(unsigned(data(
4457                                                TRV_DELAY_VALUE_H downto TRV_DELAY_VALUE_L)));
4458                        end procedure;
4459                    
4460                    
4461                    
4462                        procedure CAN_read_timestamp(
4463                            variable ts	            : out   std_logic_vector(63 downto 0);
4464                            constant node           : in    t_feature_node;
4465                            signal   channel        : inout t_com_channel
4466                        ) is
4467                            variable lower_word     :       std_logic_vector(31 downto 0);
4468                            variable upper_word     :       std_logic_vector(31 downto 0);
4469                        begin
4470       1/1                  CAN_read(lower_word, TIMESTAMP_LOW_ADR, node, channel);
4471       1/1                  CAN_read(upper_word, TIMESTAMP_HIGH_ADR, node, channel);
4472                    
4473       1/1                  ts := upper_word &amp; lower_word;
4474                        end procedure;
4475                    
4476                    
4477                        procedure CAN_configure_ssp(
4478                            constant ssp_source     : in    SSP_set_command_type;
4479                            constant ssp_offset_val : in    std_logic_vector(7 downto 0);
4480                            constant node           : in    t_feature_node;
4481                            signal   channel        : inout t_com_channel
4482                        ) is
4483                            variable data           :       std_logic_vector(15 downto 0) :=
4484                                                                (OTHERS =&gt; '0');
4485                            variable low            :       integer;
4486                            variable high           :       integer;
4487                        begin
4488       1/1                  low := SSP_SRC_L mod 16;
4489       1/1                  high := SSP_SRC_H mod 16;
4490                    
4491       1/1                  case ssp_source is
4492                                when ssp_meas_n_offset =&gt;
4493       1/1                          data(high downto low) := SSP_SRC_MEAS_N_OFFSET;
4494                                when ssp_no_ssp =&gt;
4495       1/1                         data(high downto low) := SSP_SRC_NO_SSP;
4496                                when ssp_offset =&gt;
4497       1/1                          data(high downto low) := SSP_SRC_OFFSET;
4498                                when others =&gt;
4499       <font color = "red">0/1     ==>                  error_m(&quot;Unsupported SSP type.&quot;);</font>
4500                                end case;
4501                    
4502       1/1                  low := SSP_OFFSET_L mod 16;
4503       1/1                  high := SSP_OFFSET_H mod 16;
4504       1/1                  data(high downto low) := ssp_offset_val;
4505                    
4506       1/1                  CAN_write(data, SSP_CFG_ADR, node, channel);
4507                        end procedure;
4508                    
4509                    
4510                        procedure CAN_read_pc_debug_m(
4511                            variable pc_dbg         : out   SW_PC_Debug;
4512                            constant node           : in    t_feature_node;
4513                            signal   channel        : inout t_com_channel
4514                        ) is
4515                            variable data           :       std_logic_vector(31 downto 0) :=
4516                                                                (OTHERS =&gt; '0');
4517                        begin
4518       1/1                  CAN_read(data, DEBUG_REGISTER_ADR, node, channel);
4519                    
4520       1/1                  pc_dbg := pc_deb_none;
4521       1/1                  if (data(PC_ARB_IND) = '1') then
4522       1/1                      pc_dbg := pc_deb_arbitration;
4523                            elsif (data(PC_CON_IND) = '1') then
4524       1/1                      pc_dbg := pc_deb_control;
4525                            elsif (data(PC_DAT_IND) = '1') then
4526       1/1                      pc_dbg := pc_deb_data;
4527                            elsif (data(PC_STC_IND) = '1') then
4528       1/1                      pc_dbg := pc_deb_stuff_count;
4529                            elsif (data(PC_CRC_IND) = '1') then
4530       1/1                      pc_dbg := pc_deb_crc;
4531                            elsif (data(PC_CRCD_IND) = '1') then
4532       1/1                      pc_dbg := pc_deb_crc_delim;
4533                            elsif (data(PC_ACK_IND) = '1') then
4534       1/1                      pc_dbg := pc_deb_ack;
4535                            elsif (data(PC_ACKD_IND) = '1') then
4536       1/1                      pc_dbg := pc_deb_ack_delim;
4537                            elsif (data(PC_EOF_IND) = '1') then
4538       1/1                      pc_dbg := pc_deb_eof;
4539                            elsif (data(PC_INT_IND) = '1') then
4540       1/1                      pc_dbg := pc_deb_intermission;
4541                            elsif (data(PC_SUSP_IND) = '1') then
4542       1/1                      pc_dbg := pc_deb_suspend;
4543                            elsif (data(PC_OVR_IND) = '1') then
4544       1/1                      pc_dbg := pc_deb_overload;
4545                            elsif (data(PC_SOF_IND) = '1') then
4546       1/1                      pc_dbg := pc_deb_sof;
4547                            end if;
4548                        end procedure;
4549                    
4550                    
4551                        procedure CAN_wait_pc_state(
4552                            constant pc_state       : in    SW_PC_Debug;
4553                            constant node           : in    t_feature_node;
4554                            signal   channel        : inout t_com_channel
4555                        )is
4556                            variable read_state     :       SW_PC_Debug;
4557                        begin
4558       1/1                  info_m(&quot;Waiting till node: &quot; &amp; t_feature_node'image(node) &amp;
4559                                   &quot; is in state: &quot; &amp; SW_PC_Debug'image(pc_state));
4560       1/1                  mem_bus_agent_disable_transaction_reporting(channel);
4561                    
4562       1/1                  CAN_read_pc_debug_m(read_state, node, channel);
4563       1/1                  while (read_state /= pc_state) loop
4564       1/1                      clk_agent_wait_cycle(channel);
4565       1/1                      CAN_read_pc_debug_m(read_state, node, channel);
4566                            end loop;
4567                    
4568       1/1                  mem_bus_agent_enable_transaction_reporting(channel);
4569       1/1                  info_m(&quot;Done&quot;);
4570                        end procedure;
4571                    
4572                    
4573                        procedure CAN_wait_not_pc_state(
4574                            constant pc_state       : in    SW_PC_Debug;
4575                            constant node           : in    t_feature_node;
4576                            signal   channel        : inout t_com_channel
4577                        )is
4578                            variable read_state     :       SW_PC_Debug;
4579                        begin
4580       1/1                  info_m(&quot;Waiting till node: &quot; &amp; t_feature_node'image(node) &amp;
4581                                   &quot; is NOT in state: &quot; &amp; SW_PC_Debug'image(pc_state));
4582       1/1                  mem_bus_agent_disable_transaction_reporting(channel);
4583                    
4584       1/1                  CAN_read_pc_debug_m(read_state, node, channel);
4585       1/1                  while (read_state = pc_state) loop
4586       1/1                      clk_agent_wait_cycle(channel);
4587       1/1                      CAN_read_pc_debug_m(read_state, node, channel);
4588                            end loop;
4589                    
4590       1/1                  mem_bus_agent_enable_transaction_reporting(channel);
4591                        end procedure;
4592                    
4593                    
4594                        procedure CAN_configure_tx_priority(
4595                            constant buff_number    : in    SW_TXT_index_type;
4596                            constant priority       : in    natural range 0 to 7;
4597                            constant node           : in    t_feature_node;
4598                            signal   channel        : inout t_com_channel
4599                       ) is
4600                            variable data           :       std_logic_vector(31 downto 0) :=
4601                                                                (OTHERS =&gt; '0');
4602                            variable address        :       std_logic_vector(11 downto 0) :=
4603                                (OTHERS =&gt; '0');
4604                        begin
4605                            -- Read current register value to variable
4606       1/1                  address := TX_PRIORITY_ADR;
4607       1/1                  CAN_read(data, address, node, channel);
4608       1/1                  info_m(&quot;Read 'TX_PRIORITY_ADR': 0x&quot; &amp; to_hstring(data) &amp; &quot;.&quot;);
4609                    
4610                           -- Select buffer and modify appropriate bits in the register
4611       1/1                  case buff_number is
4612                                when 1 =&gt;
4613       1/1                          data (2 downto 0) := std_logic_vector(to_unsigned(priority, 3));
4614                                when 2 =&gt;
4615       1/1                          data (6 downto 4) := std_logic_vector(to_unsigned(priority, 3));
4616                                when 3 =&gt;
4617       1/1                          data (10 downto 8) := std_logic_vector(to_unsigned(priority, 3));
4618                                when 4 =&gt;
4619       1/1                          data (14 downto 12) := std_logic_vector(to_unsigned(priority, 3));
4620                                when 5 =&gt;
4621       1/1                          data (18 downto 16) := std_logic_vector(to_unsigned(priority, 3));
4622                                when 6 =&gt;
4623       1/1                          data (22 downto 20) := std_logic_vector(to_unsigned(priority, 3));
4624                                when 7 =&gt;
4625       1/1                          data (26 downto 24) := std_logic_vector(to_unsigned(priority, 3));
4626                                when 8 =&gt;
4627       1/1                          data (30 downto 28) := std_logic_vector(to_unsigned(priority, 3));
4628                                when others =&gt;
4629       <font color = "red">0/1     ==>                  error_m(&quot;Unsupported TX buffer number.&quot;);</font>
4630                                end case;
4631                    
4632                            -- Write back new value and exit procedure
4633       1/1                  info_m(&quot;Write 'TX_PRIORITY_ADR': 0x&quot; &amp; to_hstring(data) &amp; &quot;.&quot;);
4634       1/1                  address := TX_PRIORITY_ADR;
4635       1/1                  CAN_write(data, address, node, channel);
4636                        end procedure;
4637                    
4638                    
4639                        procedure CAN_read_error_code_capture(
4640                            variable err_capt       : inout SW_error_capture;
4641                            constant node           : in    t_feature_node;
4642                            signal   channel        : inout t_com_channel
4643                        ) is
4644                            variable data           :       std_logic_vector(7 downto 0) :=
4645                                                                (OTHERS =&gt; '0');
4646                            variable low            :       integer;
4647                            variable high           :       integer;
4648                        begin
4649       1/1                  CAN_read(data, ERR_CAPT_ADR, node, channel);
4650                    
4651       1/1                  low := ERR_TYPE_L mod 8;
4652       1/1                  high := ERR_TYPE_H mod 8;
4653       1/1                  case data(high downto low) is
4654       1/1                  when ERC_BIT_ERR  =&gt; err_capt.err_type := can_err_bit;
4655       1/1                  when ERC_CRC_ERR  =&gt; err_capt.err_type := can_err_crc;
4656       1/1                  when ERC_FRM_ERR  =&gt; err_capt.err_type := can_err_form;
4657       1/1                  when ERC_ACK_ERR  =&gt; err_capt.err_type := can_err_ack;
4658       1/1                  when ERC_STUF_ERR =&gt; err_capt.err_type := can_err_stuff;
4659                            when others =&gt;
4660       <font color = "red">0/1     ==>              error_m(&quot;Unknown Error type in Error code capture register!&quot;);</font>
4661                            end case;
4662                    
4663       1/1                  low := ERR_POS_L mod 8;
4664       1/1                  high := ERR_POS_H mod 8;
4665       1/1                  case data(high downto low) is
4666       1/1                  when ERC_POS_SOF    =&gt; err_capt.err_pos := err_pos_sof;
4667       1/1                  when ERC_POS_ARB    =&gt; err_capt.err_pos := err_pos_arbitration;
4668       1/1                  when ERC_POS_CTRL   =&gt; err_capt.err_pos := err_pos_ctrl;
4669       1/1                  when ERC_POS_DATA   =&gt; err_capt.err_pos := err_pos_data;
4670       1/1                  when ERC_POS_CRC    =&gt; err_capt.err_pos := err_pos_crc;
4671       1/1                  when ERC_POS_ACK    =&gt; err_capt.err_pos := err_pos_ack;
4672       1/1                  when ERC_POS_EOF    =&gt; err_capt.err_pos := err_pos_eof;
4673       1/1                  when ERC_POS_ERR    =&gt; err_capt.err_pos := err_pos_err_frame;
4674       1/1                  when ERC_POS_OVRL   =&gt; err_capt.err_pos := err_pos_overload_frame;
4675       1/1                  when ERC_POS_OTHER  =&gt; err_capt.err_pos := err_pos_other;
4676                            when others =&gt;
4677       <font color = "red">0/1     ==>              error_m(&quot;Unknown Error position in Error code capture register!&quot;);</font>
4678                            end case;
4679                    
4680                        end procedure;
4681                    
4682                    
4683                        procedure CAN_read_retr_ctr(
4684                            variable retr_ctr       : out   natural;
4685                            constant node           : in    t_feature_node;
4686                            signal   channel        : inout t_com_channel
4687                        ) is
4688                            variable data : std_logic_vector(7 downto 0);
4689                        begin
4690       1/1                  CAN_read(data, RETR_CTR_ADR, node, channel);
4691       1/1                  retr_ctr := to_integer(unsigned(data));
4692                        end procedure;
4693                    
4694                    
4695                        procedure CAN_wait_sample_point(
4696                            constant node               : in    t_feature_node;
4697                            signal   channel            : inout t_com_channel;
4698                            constant skip_stuff_bits    : in    boolean := true
4699                        ) is
4700                            variable node_i  : integer;
4701                        begin
4702       1/1                  if (node = DUT_NODE) then
4703       1/1                      node_i := 0;
4704                            else
4705       1/1                      node_i := 1;
4706                            end if;
4707       1/1                  test_probe_agent_wait_sample(channel, node_i, skip_stuff_bits);
4708                        end procedure;
4709                    
4710                    
4711                        procedure CAN_wait_sync_seg(
4712                            constant node               : in    t_feature_node;
4713                            signal   channel            : inout t_com_channel
4714                        ) is
4715                            variable node_i  : integer;
4716                        begin
4717       1/1                  if (node = DUT_NODE) then
4718       1/1                      node_i := 0;
4719                            else
4720       <font color = "red">0/1     ==>              node_i := 1;</font>
4721                            end if;
4722       1/1                  test_probe_agent_wait_sync(channel, node_i);
4723                        end procedure;
4724                    
4725                    
4726                        procedure CAN_init_txtb_mems(
4727                            constant node           : in    t_feature_node;
4728                            signal   channel        : inout t_com_channel
4729                        ) is
4730                            variable address : std_logic_vector(11 downto 0);
4731                            variable data    : std_logic_vector(31 downto 0):= (OTHERS =&gt; '0');
4732                            variable num_bufs : integer;
4733                        begin
4734       1/1                  mem_bus_agent_disable_transaction_reporting(channel);
4735       1/1                  get_tx_buf_count(num_bufs, node, channel);
4736                    
4737       1/1                  for i in 1 to num_bufs loop
4738       1/1                      address := std_logic_vector(to_unsigned(
4739                                            to_integer((unsigned(TXTB1_DATA_1_ADR)) * i), 12));
4740       1/1                      for j in 0 to 20 loop
4741       1/1                          CAN_write(data, address, node, channel);
4742       1/1                          address := std_logic_vector(unsigned(address) + 4);
4743                                end loop;
4744                            end loop;
4745       1/1                  mem_bus_agent_enable_transaction_reporting(channel);
4746                        end procedure;
4747                    
4748                        procedure CAN_generate_random_bit_timing(
4749                            variable bt         : inout   bit_time_config_type;
4750                            signal   channel    : inout t_com_channel
4751                        ) is
4752                        begin
4753                            -- Generate random Nominal bit rate!
4754       1/1                  rand_int_v(127, bt.prop_nbt);
4755       1/1                  rand_int_v(63, bt.ph1_nbt);
4756       1/1                  rand_int_v(63, bt.ph2_nbt);
4757                            -- Longer TQ is possible but test run-time is killing us!
4758       1/1                  rand_int_v(32, bt.tq_nbt);
4759       1/1                  rand_int_v(33, bt.sjw_nbt);
4760                    
4761                            -- Generate random Nominal bit rate!
4762       1/1                  rand_int_v(63, bt.prop_dbt);
4763       1/1                  rand_int_v(31, bt.ph1_dbt);
4764       1/1                  rand_int_v(31, bt.ph2_dbt);
4765                            -- Constrain time quanta to something realistinc for data phase so
4766                            -- that we don't have too long run times!
4767       1/1                  rand_int_v(16, bt.tq_dbt);
4768       1/1                  rand_int_v(33, bt.sjw_dbt);
4769                    
4770                            -- Constrain minimal BRP (0 is not allowed)!
4771       1/1                  if (bt.tq_nbt = 0) then
4772       <font color = "red">0/1     ==>              bt.tq_nbt := 1;</font>
4773                            end if;
4774       1/1                  if (bt.tq_dbt = 0) then
4775       <font color = "red">0/1     ==>              bt.tq_dbt := 1;</font>
4776                            end if;
4777                    
4778                            -- Make sure we have at least 10 cycles in nominal bit-rate
4779                            -- (TSEG1=6 and TSEG2=4). This is what we have described as
4780                            -- recommended minimum in datasheet!
4781       1/1                  if (bt.tq_nbt * (bt.prop_nbt + bt.ph1_dbt + 1) &lt; 6) then
4782       <font color = "red">0/1     ==>              bt.prop_nbt := 3;</font>
4783       <font color = "red">0/1     ==>              bt.ph1_nbt := 3;</font>
4784                            end if;
4785       1/1                  if (bt.tq_nbt * bt.ph2_nbt &lt; 4) then
4786       <font color = "red">0/1     ==>              bt.ph2_nbt := 4;</font>
4787                            end if;
4788                    
4789                            -- Make sure we have at least 5 clock cycles in data bit-rate
4790                            -- (TSEG1 = 3 and TSEG2 = 2), this is absolute minimum!
4791       1/1                  if (bt.tq_dbt * (bt.prop_dbt + bt.ph1_dbt + 1) &lt; 3) then
4792       <font color = "red">0/1     ==>              bt.prop_dbt := 1;</font>
4793       <font color = "red">0/1     ==>              bt.ph1_dbt := 1;</font>
4794                            end if;
4795       1/1                  if (bt.tq_dbt * bt.ph2_dbt &lt; 2) then
4796       <font color = "red">0/1     ==>              bt.ph2_dbt := 2;</font>
4797                            end if;
4798                    
4799                            -- Make sure we have SJW at least 1
4800       1/1                  if (bt.sjw_nbt = 0) then
4801       <font color = "red">0/1     ==>              bt.sjw_dbt := 1;</font>
4802                            end if;
4803       1/1                  if (bt.sjw_dbt = 0) then
4804       <font color = "red">0/1     ==>              bt.sjw_dbt := 1;</font>
4805                            end if;
4806                    
4807                        end procedure;
4808                    
4809                    
4810                        procedure CAN_check_test_registers(
4811                            variable regs_present   : inout boolean;
4812                            constant node           : in    t_feature_node;
4813                            signal   channel        : inout t_com_channel
4814                        ) is
4815                            variable data           :       std_logic_vector(31 downto 0);
4816                        begin
4817                            -- Status register
4818       1/1                  CAN_read(data, STATUS_ADR, node, channel);
4819       1/1                  if (data(STRGS_IND) = '1') then
4820       1/1                      regs_present := true;
4821                            else
4822       <font color = "red">0/1     ==>              regs_present := false;</font>
</pre>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="tag_CTU_CAN_FD_TB.FEATURE_TEST_AGENT_PKG">
    <li>
      <a href="#Line">Line</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
