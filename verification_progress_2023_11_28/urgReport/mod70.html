<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: CTU_CAN_FD_TB.MEM_BUS_AGENT_PKG</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-west">
<div name='tag_CTU_CAN_FD_TB.MEM_BUS_AGENT_PKG'>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_CTU_CAN_FD_TB.MEM_BUS_AGENT_PKG')">CTU_CAN_FD_TB.MEM_BUS_AGENT_PKG</a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s7 cl rt"> 73.28</td>
<td class="s7 cl rt"><a href="mod70.html#Line" > 73.28</a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/home/oille/Downloads/ctucanfd_ip_core/test/main_tb/agents/memory_bus_agent/mem_bus_agent_pkg.vhd')">/home/oille/Downloads/ctucanfd_ip_core/test/main_tb/agents/memory_bus_agent/mem_bus_agent_pkg.vhd</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr></table></div>
</div>
<br clear=all>
</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_CTU_CAN_FD_TB.MEM_BUS_AGENT_PKG'>
<a name="Line"></a>
Line Coverage for Module : <a href="mod70.html" >CTU_CAN_FD_TB.MEM_BUS_AGENT_PKG</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">TOTAL</td><td></td><td>131</td><td>96</td><td>73.28</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>416</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>426</td><td>3</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>444</td><td>3</td><td>0</td><td>0.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>463</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>482</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>497</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>507</td><td>3</td><td>0</td><td>0.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>518</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>530</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>542</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">VHDL_PROCEDURE</td><td>553</td><td>3</td><td>0</td><td>0.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>564</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s5"><td class="lf">VHDL_FUNCTION</td><td>579</td><td>7</td><td>4</td><td>57.14</td></tr>
<tr class="s9"><td class="lf">VHDL_PROCEDURE</td><td>604</td><td>20</td><td>18</td><td>90.00</td></tr>
<tr class="s8"><td class="lf">VHDL_PROCEDURE</td><td>648</td><td>12</td><td>10</td><td>83.33</td></tr>
<tr class="s7"><td class="lf">VHDL_PROCEDURE</td><td>683</td><td>13</td><td>10</td><td>76.92</td></tr>
<tr class="s3"><td class="lf">VHDL_PROCEDURE</td><td>725</td><td>17</td><td>6</td><td>35.29</td></tr>
<tr class="s8"><td class="lf">VHDL_PROCEDURE</td><td>768</td><td>15</td><td>13</td><td>86.67</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>797</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">VHDL_PROCEDURE</td><td>807</td><td>3</td><td>3</td><td>100.00</td></tr>
</table>
<pre class="code"><br clear=all>
415                         begin
416        1/1                  info_m(MEM_BUS_AGENT_TAG &amp; &quot;Starting&quot;);
417        1/1                  send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_START);
418        1/1                  debug_m(MEM_BUS_AGENT_TAG &amp; &quot;Started&quot;);
419                         end procedure;
420                     
421                     
422                         procedure mem_bus_agent_stop(
423                             signal      channel     : inout t_com_channel
424                         ) is
425                         begin
426        <font color = "red">0/1     ==>          info_m(MEM_BUS_AGENT_TAG &amp; &quot;Stopping&quot;);</font>
427        <font color = "red">0/1     ==>          send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_STOP);</font>
428        <font color = "red">0/1     ==>          debug_m(MEM_BUS_AGENT_TAG &amp; &quot;Stopped&quot;);</font>
429                         end procedure;
430                     
431                     
432                         procedure mem_bus_agent_write_non_blocking(
433                             signal      channel     : inout t_com_channel;
434                                         address     : in    integer;
435                                         write_data  : in    std_logic_vector(31 downto 0);
436                                         byte_enable : in    std_logic_vector(3 downto 0)
437                         )  is
438                         begin
439                             --debug_m(MEM_BUS_AGENT_TAG &amp; &quot;Posting non-blocking write, Address: 0x&quot; &amp;
440                             --       to_hstring(std_logic_vector(to_unsigned(address, 16))) &amp;
441                             --      &quot; &quot; &amp; to_hstring(write_data));
442                     
443                             -- Pack the transaction to parameter vector
444        <font color = "red">0/1     ==>          com_channel_data.set_param(address);</font>
445        <font color = "red">0/1     ==>          com_channel_data.set_param(write_data &amp; byte_enable);</font>
446        <font color = "red">0/1     ==>          send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_WRITE_NON_BLOCKING);</font>
447                     
448                             --debug_m(MEM_BUS_AGENT_TAG &amp; &quot;Mem bus agent non-blocking write posted&quot;);
449                         end procedure;
450                     
451                     
452                         procedure mem_bus_agent_write_blocking(
453                             signal      channel     : inout t_com_channel;
454                                         address     : in    integer;
455                                         write_data  : in    std_logic_vector(31 downto 0);
456                                         byte_enable : in    std_logic_vector(3 downto 0)
457                         )  is
458                         begin
459                             --debug_m(MEM_BUS_AGENT_TAG &amp; &quot;Blocking write, Address: 0x&quot; &amp;
460                             --       to_hstring(std_logic_vector(to_unsigned(address, 16))) &amp;
461                             --      &quot; &quot; &amp; to_hstring(write_data));
462                     
463        1/1                  com_channel_data.set_param(address);
464        1/1                  com_channel_data.set_param(write_data &amp; byte_enable);
465        1/1                  send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_WRITE_BLOCKING);
466                     
467                             --debug_m(MEM_BUS_AGENT_TAG &amp; &quot;Blocking write succesfull&quot;);
468                         end procedure;
469                     
470                     
471                         procedure mem_bus_agent_read(
472                             signal      channel     : inout t_com_channel;
473                                         address     : in    integer;
474                             variable    read_data   : inout std_logic_vector(31 downto 0);
475                                         byte_enable : in    std_logic_vector(3 downto 0)
476                         ) is
477                             variable tmp : std_logic_vector(127 downto 0);
478                         begin
479                             --info_m(MEM_BUS_AGENT_TAG &amp; &quot;Read, Address: 0x&quot; &amp;
480                             --       to_hstring(std_logic_vector(to_unsigned(address, 16))));
481                     
482        1/1                  com_channel_data.set_param(address);
483        1/1                  com_channel_data.set_param(byte_enable);
484        1/1                  send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_READ);
485                     
486        1/1                  tmp := com_channel_data.get_param;
487        1/1                  read_data := tmp(31 downto 0);
488        1/1                  wait for 0 ns;
489                             --info_m(MEM_BUS_AGENT_TAG &amp; &quot;Read done, read data: 0x&quot; &amp; to_hstring(read_data));
490                         end procedure;
491                     
492                     
493                         procedure mem_bus_agent_x_mode_start(
494                             signal      channel     : inout t_com_channel
495                         ) is
496                         begin
497        1/1                  info_m(MEM_BUS_AGENT_TAG &amp; &quot;Enabling X mode&quot;);
498        1/1                  send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_X_MODE_START);
499        1/1                  debug_m(MEM_BUS_AGENT_TAG &amp; &quot;X mode enabled&quot;);
500                         end procedure;
501                     
502                     
503                         procedure mem_bus_agent_x_mode_stop(
504                             signal      channel     : inout t_com_channel
505                         ) is
506                         begin
507        <font color = "red">0/1     ==>          info_m(MEM_BUS_AGENT_TAG &amp; &quot;Disabling X mode&quot;);</font>
508        <font color = "red">0/1     ==>          send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_X_MODE_STOP);</font>
509        <font color = "red">0/1     ==>          debug_m(MEM_BUS_AGENT_TAG &amp; &quot;X mode disabled&quot;);</font>
510                         end procedure;
511                     
512                     
513                         procedure mem_bus_agent_set_x_mode_setup(
514                             signal      channel     : inout t_com_channel;
515                                         setup       : in    time
516                         ) is
517                         begin
518        1/1                  info_m(MEM_BUS_AGENT_TAG &amp; &quot;Setting X mode setup to: &quot; &amp; time'image(setup));
519        1/1                  com_channel_data.set_param(setup);
520        1/1                  send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_SET_X_MODE_SETUP);
521        1/1                  debug_m(MEM_BUS_AGENT_TAG &amp; &quot;X mode setup configured&quot;);
522                         end procedure;
523                     
524                     
525                         procedure mem_bus_agent_set_x_mode_hold(
526                             signal      channel     : inout t_com_channel;
527                                         hold        : in    time
528                         ) is
529                         begin
530        1/1                  info_m(MEM_BUS_AGENT_TAG &amp; &quot;Setting X mode hold to: &quot; &amp; time'image(hold));
531        1/1                  com_channel_data.set_param(hold);
532        1/1                  send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_SET_X_MODE_HOLD);
533        1/1                  debug_m(MEM_BUS_AGENT_TAG &amp; &quot;X mode hold configured&quot;);
534                         end procedure;
535                     
536                     
537                         procedure mem_bus_agent_set_output_delay(
538                             signal      channel     : inout t_com_channel;
539                                         out_delay   : in    time
540                         ) is
541                         begin
542        1/1                  info_m(MEM_BUS_AGENT_TAG &amp; &quot;Setting data out output delay &quot; &amp; time'image(out_delay));
543        1/1                  com_channel_data.set_param(out_delay);
544        1/1                  send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_SET_OUTPUT_DELAY);
545        1/1                  debug_m(MEM_BUS_AGENT_TAG &amp; &quot;data out output delay set&quot;);
546                         end procedure;
547                     
548                     
549                         procedure mem_bus_agent_wait_done(
550                             signal      channel     : inout t_com_channel
551                         ) is
552                         begin
553        <font color = "red">0/1     ==>          info_m(MEM_BUS_AGENT_TAG &amp; &quot;Waiting till all accesses are executed&quot;);</font>
554        <font color = "red">0/1     ==>          send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_WAIT_DONE);</font>
555        <font color = "red">0/1     ==>          info_m(MEM_BUS_AGENT_TAG &amp; &quot;All accesses are executed!&quot;);</font>
556                         end procedure;
557                     
558                     
559                         procedure mem_bus_agent_set_slave_index(
560                             signal      channel     : inout t_com_channel;
561                                         node        : in    natural
562                         ) is
563                         begin
564        1/1                  com_channel_data.set_param(node);
565        1/1                  send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_SET_SLAVE_INDEX);
566                         end procedure;
567                     
568                     
569                         ---------------------------------------------------------------------------
570                         -- 8, 16 and 32 bits accesses are supported. Also bursts of multiples of
571                         -- 32 bits. Unaligned accesses are not supported (e.g. writing 4 byte buffer
572                         -- to address 0x2).
573                         ---------------------------------------------------------------------------
574                         function check_access_size(
575                             address     : in    integer;
576                             size        : in    natural
577                         ) return boolean is
578                         begin
579        1/1                  if ((size /= 8) and (size /= 16) and ((size mod 32) /= 0)) then
580        <font color = "red">0/1     ==>              return false;</font>
581                             end if;
582                     
583                             -- Half-word unaligned access
584        1/1                  if ((size = 16) and ((address mod 2) /= 0)) then
585        <font color = "red">0/1     ==>              return false;</font>
586                             end if;
587                     
588                             -- Word unaligned access
589        1/1                  if ((size mod 32) = 0) and ((address mod 4) /= 0) then
590        <font color = "red">0/1     ==>              return false;</font>
591                             end if;
592                     
593        1/1                  return true;
594                         end function;
595                     
596                     
597                         procedure convert_be_and_write_data(
598                                      address     : in    natural;
599                                      data_in     : in    std_logic_vector;
600                             variable be          : out   std_logic_vector(3 downto 0);
601                             variable write_data  : out   std_logic_vector(31 downto 0)
602                         ) is
603                         begin
604        1/1                  write_data := (OTHERS =&gt; '0');
605        1/1                  case data_in'length is
606                             when 8 =&gt;
607        1/1                      case (address mod 4) is
608                                 when 0 =&gt;
609        1/1                          be := &quot;0001&quot;;
610        1/1                          write_data(7 downto 0) := data_in;
611                                 when 1 =&gt;
612        1/1                          be := &quot;0010&quot;;
613        1/1                          write_data(15 downto 8) := data_in;
614                                 when 2 =&gt;
615        1/1                          be := &quot;0100&quot;;
616        1/1                          write_data(23 downto 16) := data_in;
617                                 when 3 =&gt;
618        1/1                          be := &quot;1000&quot;;
619        1/1                          write_data(31 downto 24) := data_in;
620                                 when others =&gt;
621        <font color = "red">0/1     ==>                  error_m(&quot;Unreachable code -&gt; Simulator bug?&quot;);</font>
622                                 end case;
623                             when 16 =&gt;
624        1/1                      case (address mod 4) is
625                                 when 0 =&gt;
626        1/1                          be := &quot;0011&quot;;
627        1/1                          write_data(15 downto 0) := data_in;
628                                 when 2 =&gt;
629        1/1                          be := &quot;1100&quot;;
630        1/1                          write_data(31 downto 16) := data_in;
631                                 when others =&gt;
632        <font color = "red">0/1     ==>                  error_m(&quot;Unsupported 16 bit write at addr: &quot; &amp; to_string(address));</font>
633                                 end case;
634                             when others =&gt;
635        1/1                      be := &quot;1111&quot;;
636        1/1                      write_data(31 downto 0) := data_in;
637                             end case;
638                         end procedure;
639                     
640                     
641                         procedure convert_be(
642                                      address     : in    natural;
643                                      data_in     : in    std_logic_vector;
644                             variable be          : out   std_logic_vector(3 downto 0)
645                         )is
646                         begin
647                     
648        1/1                  case data_in'length is
649                             when 8 =&gt;
650        1/1                      case (address mod 4) is
651                                 when 0 =&gt;
652        1/1                          be := &quot;0001&quot;;
653                                 when 1 =&gt;
654        1/1                          be := &quot;0010&quot;;
655                                 when 2 =&gt;
656        1/1                          be := &quot;0100&quot;;
657                                 when 3 =&gt;
658        1/1                          be := &quot;1000&quot;;
659                                 when others =&gt;
660        <font color = "red">0/1     ==>                  error_m(&quot;Unreachable code -&gt; Simulator bug?&quot;);</font>
661                                 end case;
662                             when 16 =&gt;
663        1/1                      case (address mod 4) is
664                                 when 0 =&gt;
665        1/1                          be := &quot;0011&quot;;
666                                 when 2 =&gt;
667        1/1                          be := &quot;1100&quot;;
668                                 when others =&gt;
669        <font color = "red">0/1     ==>                  error_m(&quot;16 bit access must be half-word aligned!&quot;);</font>
670                                 end case;
671                             when others =&gt;
672        1/1                      be := &quot;1111&quot;;
673                             end case;
674                         end procedure;
675                     
676                         procedure convert_read_data(
677                                      address             : in    natural;
678                                      size                : in    natural;
679                                      data_in             : in    std_logic_vector(31 downto 0);
680                             variable data_out            : out   std_logic_vector
681                         )is
682                         begin
683        1/1                  case size is
684                             when 8 =&gt;
685        1/1                      case (address mod 4) is
686                                 when 0 =&gt;
687        1/1                          data_out(7 downto 0) := data_in(7 downto 0);
688                                 when 1 =&gt;
689        1/1                          data_out(7 downto 0) := data_in(15 downto 8);
690                                 when 2 =&gt;
691        1/1                          data_out(7 downto 0) := data_in(23 downto 16);
692                                 when 3 =&gt;
693        1/1                          data_out(7 downto 0) := data_in(31 downto 24);
694                                 when others =&gt;
695        <font color = "red">0/1     ==>                  error_m(&quot;Invalid 32 bit access!&quot;);</font>
696                                 end case;
697                             when 16 =&gt;
698        1/1                      case (address mod 4) is
699                                 when 0 =&gt;
700        1/1                          data_out(15 downto 0) := data_in(15 downto 0);
701                                 when 2 =&gt;
702        1/1                          data_out(15 downto 0) := data_in(31 downto 16);
703                                 when others =&gt;
704        <font color = "red">0/1     ==>                  error_m(&quot;Invalid address for 16 bit access!&quot;);</font>
705                                 end case;
706                             when 32 =&gt;
707        1/1                      data_out := data_in;
708                             when others =&gt;
709        <font color = "red">0/1     ==>              error_m(&quot;Unknown access size: &quot; &amp; integer'image(size));</font>
710                             end case;
711                         end;
712                     
713                         procedure mem_bus_agent_write(
714                             signal      channel     : inout t_com_channel;
715                                         address     : in    integer;
716                                         write_data  : in    std_logic_vector;
717                                         blocking    : in    boolean := true
718                         ) is
719                             variable addr_aligned   :       integer;
720                             variable addr_loop      :       integer;
721                             variable be             :       std_logic_vector(3 downto 0);
722                             variable data_32        :       std_logic_vector(31 downto 0);
723                             variable loop_count     :       integer;
724                         begin
725        1/1                  if (not check_access_size(address, write_data'length)) then
726        <font color = "red">0/1     ==>              return;</font>
727                             end if;
728                     
729        1/1                  if (write_data'length = 8 or write_data'length = 16 or write_data'length = 32) then
730        1/1                      addr_aligned := address - (address mod 4);
731        1/1                      convert_be_and_write_data(address, write_data, be, data_32);
732        1/1                      if (blocking) then
733        1/1                          mem_bus_agent_write_blocking(channel, addr_aligned, data_32, be);
734                                 else
735        <font color = "red">0/1     ==>                  mem_bus_agent_write_non_blocking(channel, addr_aligned, data_32, be);</font>
736                                 end if;
737                             else
738        <font color = "red">0/1     ==>              loop_count := write_data'length / 32;</font>
739        <font color = "red">0/1     ==>              addr_loop := address;</font>
740                                 -- For burst accesses, always 32 bit
741        <font color = "red">0/1     ==>              be := x&quot;F&quot;;</font>
742                     
743        <font color = "red">0/1     ==>              for i in 0 to loop_count-1 loop</font>
744        <font color = "red">0/1     ==>                  data_32 := write_data(i*32+31 downto i*32);</font>
745        <font color = "red">0/1     ==>                  if (blocking) then</font>
746        <font color = "red">0/1     ==>                      mem_bus_agent_write_blocking(channel, addr_loop, data_32, be);</font>
747                                     else
748        <font color = "red">0/1     ==>                      mem_bus_agent_write_non_blocking(channel, addr_loop, data_32, be);</font>
749                                     end if;
750        <font color = "red">0/1     ==>                  addr_loop := addr_loop + 4;</font>
751                                 end loop;
752                             end if;
753                         end procedure;
754                     
755                     
756                         procedure mem_bus_agent_read(
757                             signal      channel     : inout t_com_channel;
758                                         address     : in    integer;
759                             variable    read_data   : inout std_logic_vector;
760                             constant    stat_burst  : in    boolean := false
761                         ) is
762                             variable addr_aligned   :       integer;
763                             variable addr_loop      :       integer;
764                             variable be             :       std_logic_vector(3 downto 0);
765                             variable data_32        :       std_logic_vector(31 downto 0);
766                             variable loop_count     :       integer;
767                         begin
768        1/1                  if (not check_access_size(address, read_data'length)) then
769        <font color = "red">0/1     ==>              return;</font>
770                             end if;
771                     
772        1/1                  if (read_data'length = 8 or read_data'length = 16 or read_data'length = 32) then
773        1/1                      addr_aligned := address - (address mod 4);
774        1/1                      convert_be(address, read_data, be);
775        1/1                      mem_bus_agent_read(channel, addr_aligned, data_32, be);
776        1/1                      convert_read_data(address, read_data'length, data_32, read_data);
777                             else
778        1/1                      loop_count := read_data'length / 32;
779        1/1                      addr_loop := address;
780                                 -- For burst accesses, always 32 bit
781        1/1                      be := x&quot;F&quot;;
782                     
783        1/1                      for i in 0 to loop_count-1 loop
784        1/1                          mem_bus_agent_read(channel, addr_loop, data_32, be);
785        1/1                          read_data(i*32+31 downto i*32) := data_32;
786        1/1                          if (stat_burst = false) then
787        <font color = "red">0/1     ==>                      addr_loop := addr_loop + 4;</font>
788                                     end if;
789                                 end loop;
790                             end if;
791                         end procedure;
792                     
793                         procedure mem_bus_agent_enable_transaction_reporting(
794                             signal      channel     : inout t_com_channel
795                         ) is
796                         begin
797        1/1                  debug_m(MEM_BUS_AGENT_TAG &amp; &quot;Enabling transaction reporting&quot;);
798        1/1                  send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_ENABLE_TRANS_REPORT);
799        1/1                  debug_m(MEM_BUS_AGENT_TAG &amp; &quot;Transaction reporting enabled&quot;);
800                         end procedure;
801                     
802                     
803                         procedure mem_bus_agent_disable_transaction_reporting(
804                             signal      channel     : inout t_com_channel
805                         ) is
806                         begin
807        1/1                  debug_m(MEM_BUS_AGENT_TAG &amp; &quot;Disabling transaction reporting&quot;);
808        1/1                  send(channel, C_MEM_BUS_AGENT_ID, MEM_BUS_AGNT_CMD_DISABLE_TRANS_REPORT);
809        1/1                  debug_m(MEM_BUS_AGENT_TAG &amp; &quot;Transaction reporting disabled&quot;);
</pre>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="tag_CTU_CAN_FD_TB.MEM_BUS_AGENT_PKG">
    <li>
      <a href="#Line">Line</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
